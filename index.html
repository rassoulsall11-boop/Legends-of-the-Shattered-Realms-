<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON VORTEX: EVOLUTION</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        :root { --primary: #00f3ff; --secondary: #ff0055; --bg: #050505; --ui-font: 'Orbitron', sans-serif; }
        * { box-sizing: border-box; user-select: none; touch-action: none; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: var(--bg); font-family: var(--ui-font); }
        #game-container { position: relative; width: 100%; height: 100%; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; padding: 20px; color: white; }
        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; pointer-events: auto; }
        .hud-left span { color: var(--primary); font-weight: 700; }
        #pause-btn { background: rgba(255,255,255,0.1); border: 1px solid var(--primary); color: white; padding: 10px; cursor: pointer; font-family: var(--ui-font); font-size: 0.8rem; }
        
        #main-menu, #game-over, #pause-menu { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(5, 5, 5, 0.9); backdrop-filter: blur(10px); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 20; }
        .hidden { display: none !important; }
        
        h1 { font-size: 2.5rem; text-align: center; background: linear-gradient(to right, var(--primary), var(--secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-transform: uppercase; }
        .countdown { font-size: 5rem; color: var(--primary); font-weight: 900; }
        
        button { margin: 10px; padding: 15px 30px; font-size: 1rem; font-family: var(--ui-font); color: var(--bg); background: var(--primary); border: none; font-weight: 900; text-transform: uppercase; cursor: pointer; min-width: 200px;}
        .home-btn { background: #555; color: white; margin-top: 20px; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="render-canvas"></canvas>
    
    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-left">
                <div>SCORE: <span id="score-display">0</span></div>
                <div style="font-size: 0.7rem; opacity: 0.7">BEST: <span id="best-display">0</span></div>
                <div style="font-size: 0.8rem; color: var(--secondary)">LVL: <span id="level-display">1</span></div>
            </div>
            <button id="pause-btn">PAUSE ||</button>
        </div>
    </div>

    <div id="main-menu">
        <h1>NEON VORTEX</h1>
        <div id="best-menu" style="color: var(--primary); margin-bottom: 20px;">RECORD: 0</div>
        <button id="start-btn">Lancer Synth√®se</button>
    </div>

    <div id="pause-menu" class="hidden">
        <div id="pause-content">
            <h1>PAUSE</h1>
            <button id="resume-btn">Reprendre</button><br>
            <button id="home-btn" class="home-btn">üè† Accueil</button>
        </div>
        <div id="count-display" class="countdown hidden">3</div>
    </div>

    <div id="game-over" class="hidden">
        <h1>√âCHEC SYST√àME</h1>
        <h2 id="final-score" style="color:white">Score: 0</h2>
        <button id="restart-btn">R√©initialiser</button>
    </div>
</div>

<script>
const CONFIG = { baseSpeed: 300, playerSpeed: 0.18, spawnRate: 0.7, levelDuration: 5, colors: { player: '#00f3ff', enemy: '#ff0055' } };

const Utils = {
    randomRange: (min, max) => Math.random() * (max - min) + min,
    lerp: (start, end, amt) => (1 - amt) * start + amt * end,
    dist: (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1)
};

class Enemy {
    constructor() { this.active = false; }
    spawn(level, w, h) {
        const side = Math.floor(Math.random() * 4);
        if(side === 0) { this.x = Math.random()*w; this.y = -30; }
        else if(side === 1) { this.x = w+30; this.y = Math.random()*h; }
        else if(side === 2) { this.x = Math.random()*w; this.y = h+30; }
        else { this.x = -30; this.y = Math.random()*h; }
        const tx = w/2 + (Math.random()-0.5)*400;
        const ty = h/2 + (Math.random()-0.5)*400;
        this.angle = Math.atan2(ty - this.y, tx - this.x);
        this.speed = (CONFIG.baseSpeed + (level * 40)) * Utils.randomRange(0.9, 1.3);
        this.active = true;
    }
    update(dt) {
        this.x += Math.cos(this.angle) * this.speed * dt;
        this.y += Math.sin(this.angle) * this.speed * dt;
        if(this.x < -150 || this.x > window.innerWidth+150 || this.y < -150 || this.y > window.innerHeight+150) this.active = false;
    }
    draw(ctx) {
        ctx.fillStyle = CONFIG.colors.enemy;
        ctx.shadowBlur = 15; ctx.shadowColor = CONFIG.colors.enemy;
        ctx.fillRect(this.x-10, this.y-10, 22, 22);
        ctx.shadowBlur = 0;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('render-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.enemies = [];
        this.player = { x: 0, y: 0, tx: 0, ty: 0 };
        this.state = 'MENU';
        this.score = 0; this.level = 1; this.timer = 0; this.spawnT = 0;
        this.highScore = localStorage.getItem('vortexBest') || 0;
        this.init();
    }
    init() {
        window.addEventListener('resize', () => this.resize());
        this.resize();
        this.updateBestDisplay();

        const input = (e) => {
            if(this.state !== 'PLAYING') return;
            const touch = e.touches ? e.touches[0] : e;
            this.player.tx = touch.clientX; this.player.ty = touch.clientY;
        };
        
        window.addEventListener('mousemove', input);
        window.addEventListener('touchstart', input, {passive: false});
        window.addEventListener('touchmove', input, {passive: false});
        
        document.getElementById('start-btn').onclick = () => this.start();
        document.getElementById('restart-btn').onclick = () => this.start();
        document.getElementById('pause-btn').onclick = () => this.pause();
        document.getElementById('resume-btn').onclick = () => this.resume();
        document.getElementById('home-btn').onclick = () => this.goHome();

        requestAnimationFrame((t) => this.loop(t));
    }

    updateBestDisplay() {
        document.getElementById('best-display').innerText = Math.floor(this.highScore);
        document.getElementById('best-menu').innerText = "RECORD: " + Math.floor(this.highScore);
    }

    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }

    start() {
        this.state = 'PLAYING'; this.score = 0; this.level = 1; this.timer = 0; this.enemies = [];
        this.player.x = this.player.tx = this.canvas.width/2;
        this.player.y = this.player.ty = this.canvas.height/2;
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('game-over').classList.add('hidden');
        document.getElementById('pause-menu').classList.add('hidden');
    }

    pause() {
        if(this.state === 'PLAYING') {
            this.state = 'PAUSED';
            document.getElementById('pause-menu').classList.remove('hidden');
            document.getElementById('pause-content').classList.remove('hidden');
            document.getElementById('count-display').classList.add('hidden');
        }
    }

    resume() {
        document.getElementById('pause-content').classList.add('hidden');
        const countEl = document.getElementById('count-display');
        countEl.classList.remove('hidden');
        let count = 3;
        countEl.innerText = count;
        
        let timer = setInterval(() => {
            count--;
            countEl.innerText = count;
            if(count <= 0) {
                clearInterval(timer);
                document.getElementById('pause-menu').classList.add('hidden');
                this.state = 'PLAYING';
            }
        }, 1000);
    }

    goHome() {
        this.saveScore();
        document.getElementById('pause-menu').classList.add('hidden');
        document.getElementById('main-menu').classList.remove('hidden');
        this.state = 'MENU';
    }

    saveScore() {
        if(this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('vortexBest', this.highScore);
            this.updateBestDisplay();
        }
    }

    loop(t) {
        const dt = Math.min(0.1, (t - (this.lastT || t)) / 1000);
        this.lastT = t;
        if(this.state === 'PLAYING') this.update(dt);
        this.draw();
        requestAnimationFrame((t) => this.loop(t));
    }

    update(dt) {
        this.timer += dt; this.spawnT += dt; this.score += dt * 20;
        if(this.timer > CONFIG.levelDuration) { this.level++; this.timer = 0; }
        
        let currentSpawnRate = Math.max(0.1, CONFIG.spawnRate - (this.level * 0.04));
        if(this.spawnT > currentSpawnRate) {
            const e = new Enemy(); e.spawn(this.level, this.canvas.width, this.canvas.height);
            this.enemies.push(e); this.spawnT = 0;
        }
        
        this.player.x = Utils.lerp(this.player.x, this.player.tx, CONFIG.playerSpeed);
        this.player.y = Utils.lerp(this.player.y, this.player.ty, CONFIG.playerSpeed);
        
        for(let i = this.enemies.length - 1; i >= 0; i--) {
            let e = this.enemies[i];
            e.update(dt);
            if(!e.active) this.enemies.splice(i, 1);
            if(Utils.dist(this.player.x, this.player.y, e.x, e.y) < 22) {
                this.saveScore();
                this.state = 'GAMEOVER';
                document.getElementById('game-over').classList.remove('hidden');
                document.getElementById('final-score').innerText = "Score Final: " + Math.floor(this.score);
            }
        }
        document.getElementById('score-display').innerText = Math.floor(this.score);
        document.getElementById('level-display').innerText = this.level;
    }

    draw() {
        this.ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.enemies.forEach(e => e.draw(this.ctx));
        
        this.ctx.save();
        this.ctx.translate(this.player.x, this.player.y);
        this.ctx.shadowBlur = 25; this.ctx.shadowColor = CONFIG.colors.player;
        this.ctx.fillStyle = "white";
        this.ctx.beginPath(); this.ctx.arc(0, 0, 13, 0, Math.PI*2); this.ctx.fill();
        this.ctx.strokeStyle = CONFIG.colors.player;
        this.ctx.lineWidth = 2; this.ctx.stroke();
        this.ctx.restore();
    }
}
new Game();
</script>
</body>
</html>
