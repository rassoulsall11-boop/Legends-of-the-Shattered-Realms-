<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON VORTEX: HARDCORE</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
        :root { --primary: #00f3ff; --secondary: #ff0055; --bg: #050505; --ui-font: 'Orbitron', sans-serif; }
        * { box-sizing: border-box; user-select: none; -webkit-user-select: none; touch-action: none; }
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: var(--bg); font-family: var(--ui-font); }
        #game-container { position: relative; width: 100%; height: 100%; }
        canvas { display: block; width: 100%; height: 100%; }
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: flex; flex-direction: column; justify-content: space-between; padding: 20px; text-shadow: 0 0 10px rgba(0, 243, 255, 0.5); }
        .hud-top { display: flex; justify-content: space-between; font-size: 1.2rem; color: white; z-index: 10; }
        .hud-score span { color: var(--primary); font-weight: 700; }
        .hud-level span { color: var(--secondary); font-weight: 700; }
        #main-menu, #game-over { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(5, 5, 5, 0.85); backdrop-filter: blur(10px); display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 20; pointer-events: auto; }
        .hidden { display: none !important; }
        h1 { font-size: 3rem; color: white; text-align: center; margin: 0; background: linear-gradient(to right, var(--primary), var(--secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-transform: uppercase; letter-spacing: 4px; }
        button { margin-top: 30px; padding: 15px 40px; font-size: 1.2rem; font-family: var(--ui-font); color: var(--bg); background: var(--primary); border: none; clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%); cursor: pointer; font-weight: 900; text-transform: uppercase; }
        #tutorial { margin-top: 20px; font-size: 0.8rem; color: #888; text-align: center; line-height: 1.6; }
    </style>
</head>
<body>

<div id="game-container">
    <canvas id="render-canvas"></canvas>
    <div id="ui-layer">
        <div class="hud-top">
            <div class="hud-score">SCORE: <span id="score-display">0</span></div>
            <div class="hud-level">LVL: <span id="level-display">1</span></div>
        </div>
    </div>
    <div id="main-menu">
        <h1>NEON VORTEX</h1>
        <div id="tutorial">Maintenez pour bouger<br>Relâchez pour <b>TRAVERSER (INTANGIBLE)</b></div>
        <button id="start-btn">Lancer Synthèse</button>
    </div>
    <div id="game-over" class="hidden">
        <h1>ÉCHEC SYSTÈME</h1>
        <h2 id="final-score" style="color:white">Score: 0</h2>
        <button id="restart-btn">Réinitialiser</button>
    </div>
</div>

<script>
// --- CONFIGURATION DIFFICULTÉ ACCÉLÉRÉE ---
const CONFIG = { 
    baseSpeed: 300, 
    playerSpeed: 0.18, 
    spawnRate: 0.7,      // Ennemis très fréquents dès le début
    levelDuration: 5,    // On change de niveau TOUTES LES 5 SECONDES
    colors: { player: '#00f3ff', enemy: '#ff0055' } 
};

const Utils = {
    randomRange: (min, max) => Math.random() * (max - min) + min,
    lerp: (start, end, amt) => (1 - amt) * start + amt * end,
    dist: (x1, y1, x2, y2) => Math.hypot(x2 - x1, y2 - y1)
};

class Enemy {
    constructor() { this.active = false; }
    spawn(level, w, h) {
        const side = Math.floor(Math.random() * 4);
        if(side === 0) { this.x = Math.random()*w; this.y = -30; }
        else if(side === 1) { this.x = w+30; this.y = Math.random()*h; }
        else if(side === 2) { this.x = Math.random()*w; this.y = h+30; }
        else { this.x = -30; this.y = Math.random()*h; }
        
        const tx = w/2 + (Math.random()-0.5)*400;
        const ty = h/2 + (Math.random()-0.5)*400;
        this.angle = Math.atan2(ty - this.y, tx - this.x);
        
        // Vitesse qui augmente drastiquement avec le niveau
        this.speed = (CONFIG.baseSpeed + (level * 40)) * Utils.randomRange(0.9, 1.3);
        this.active = true;
    }
    update(dt) {
        this.x += Math.cos(this.angle) * this.speed * dt;
        this.y += Math.sin(this.angle) * this.speed * dt;
        if(this.x < -150 || this.x > window.innerWidth+150 || this.y < -150 || this.y > window.innerHeight+150) this.active = false;
    }
    draw(ctx) {
        ctx.fillStyle = CONFIG.colors.enemy;
        ctx.shadowBlur = 15; ctx.shadowColor = CONFIG.colors.enemy;
        ctx.fillRect(this.x-10, this.y-10, 22, 22);
        ctx.shadowBlur = 0;
    }
}

class Game {
    constructor() {
        this.canvas = document.getElementById('render-canvas');
        this.ctx = this.canvas.getContext('2d');
        this.enemies = [];
        this.player = { x: 0, y: 0, tx: 0, ty: 0, intangible: true };
        this.state = 'MENU';
        this.score = 0; this.level = 1; this.timer = 0; this.spawnT = 0;
        this.init();
    }
    init() {
        window.addEventListener('resize', () => this.resize());
        this.resize();
        
        const input = (e) => {
            if(this.state !== 'PLAYING') return;
            const touch = e.touches ? e.touches[0] : e;
            this.player.tx = touch.clientX; this.player.ty = touch.clientY;
            this.player.intangible = false; // "Travers" s'arrête quand on touche
        };
        const stop = () => { this.player.intangible = true; }; // "Travers" s'active quand on lâche
        
        window.addEventListener('mousemove', input);
        window.addEventListener('mousedown', input);
        window.addEventListener('mouseup', stop);
        window.addEventListener('touchstart', input, {passive: false});
        window.addEventListener('touchmove', input, {passive: false});
        window.addEventListener('touchend', stop);
        
        document.getElementById('start-btn').onclick = () => this.start();
        document.getElementById('restart-btn').onclick = () => this.start();
        requestAnimationFrame((t) => this.loop(t));
    }
    resize() { this.canvas.width = window.innerWidth; this.canvas.height = window.innerHeight; }
    start() {
        this.state = 'PLAYING'; this.score = 0; this.level = 1; this.timer = 0; this.enemies = [];
        this.player.x = this.player.tx = this.canvas.width/2;
        this.player.y = this.player.ty = this.canvas.height/2;
        document.getElementById('main-menu').classList.add('hidden');
        document.getElementById('game-over').classList.add('hidden');
    }
    loop(t) {
        const dt = Math.min(0.1, (t - (this.lastT || t)) / 1000);
        this.lastT = t;
        this.update(dt);
        this.draw();
        requestAnimationFrame((t) => this.loop(t));
    }
    update(dt) {
        if(this.state !== 'PLAYING') return;
        this.timer += dt; this.spawnT += dt; this.score += dt * 20;
        
        if(this.timer > CONFIG.levelDuration) { this.level++; this.timer = 0; }
        
        let currentSpawnRate = Math.max(0.1, CONFIG.spawnRate - (this.level * 0.04));
        if(this.spawnT > currentSpawnRate) {
            const e = new Enemy(); e.spawn(this.level, this.canvas.width, this.canvas.height);
            this.enemies.push(e); this.spawnT = 0;
        }
        
        this.player.x = Utils.lerp(this.player.x, this.player.tx, CONFIG.playerSpeed);
        this.player.y = Utils.lerp(this.player.y, this.player.ty, CONFIG.playerSpeed);
        
        for(let i = this.enemies.length - 1; i >= 0; i--) {
            let e = this.enemies[i];
            e.update(dt);
            if(!e.active) this.enemies.splice(i, 1);
            
            // Collision uniquement si NON-intangible
            if(!this.player.intangible && Utils.dist(this.player.x, this.player.y, e.x, e.y) < 22) {
                this.state = 'GAMEOVER';
                document.getElementById('game-over').classList.remove('hidden');
                document.getElementById('final-score').innerText = "Score Final: " + Math.floor(this.score);
            }
        }
        document.getElementById('score-display').innerText = Math.floor(this.score);
        document.getElementById('level-display').innerText = this.level;
    }
    draw() {
        this.ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        this.enemies.forEach(e => e.draw(this.ctx));
        
        this.ctx.save();
        this.ctx.translate(this.player.x, this.player.y);
        // Effet visuel du mode intangible (plus transparent)
        this.ctx.globalAlpha = this.player.intangible ? 0.25 : 1.0;
        this.ctx.shadowBlur = this.player.intangible ? 5 : 25;
        this.ctx.shadowColor = CONFIG.colors.player;
        this.ctx.fillStyle = "white";
        this.ctx.beginPath(); this.ctx.arc(0, 0, 13, 0, Math.PI*2); this.ctx.fill();
        // Cercle extérieur pour le style
        this.ctx.strokeStyle = CONFIG.colors.player;
        this.ctx.lineWidth = 2;
        this.ctx.stroke();
        this.ctx.restore();
    }
}
new Game();
</script>
</body>
</html>
