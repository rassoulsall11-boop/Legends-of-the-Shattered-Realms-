<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS DEFENDER: INFINITY | OPTIMIZED</title>
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-red: #ff0055;
            --neon-green: #00ff99;
            --bg-dark: #050505;
            --glass: rgba(255, 255, 255, 0.05);
            --font-main: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0; overflow: hidden; background-color: var(--bg-dark);
            font-family: var(--font-main); color: white; user-select: none;
        }

        #game-canvas {
            display: block; width: 100vw; height: 100vh;
            /* Force GPU acceleration context */
            will-change: transform;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; display: flex; flex-direction: column;
            justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        .hud-panel {
            background: var(--glass); backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            padding: 15px 25px; border-radius: 4px;
            text-transform: uppercase; letter-spacing: 2px; font-weight: bold;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.5);
        }

        .health-bar-container { width: 300px; height: 10px; background: rgba(255,255,255,0.1); border-radius: 5px; overflow: hidden; margin-top: 10px;}
        .health-fill { height: 100%; background: var(--neon-red); width: 100%; transition: transform 0.2s linear; transform-origin: left; }

        .modal {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 15, 0.95); border: 2px solid var(--neon-blue);
            padding: 40px; text-align: center; pointer-events: auto;
            border-radius: 8px; box-shadow: 0 0 50px rgba(0, 243, 255, 0.2);
            display: none; z-index: 100;
        }
        .modal.active { display: block; animation: fadeIn 0.3s ease; }

        .btn {
            background: transparent; border: 1px solid var(--neon-blue);
            color: var(--neon-blue); padding: 15px 40px; font-size: 1.2rem;
            cursor: pointer; text-transform: uppercase; letter-spacing: 3px;
            transition: 0.2s; margin-top: 20px; font-weight: bold;
        }
        .btn:hover { background: var(--neon-blue); color: #000; box-shadow: 0 0 20px var(--neon-blue); }

        h1 { margin: 0 0 20px; font-size: 2.5rem; text-shadow: 0 0 20px var(--neon-blue); }
        p { color: #aaa; line-height: 1.6; }

        @keyframes fadeIn { from { opacity: 0; transform: translate(-50%, -45%); } to { opacity: 1; transform: translate(-50%, -50%); } }

        /* OPTIMIZED CSS ANIMATION using Transform */
        .scanline {
            width: 100%; height: 100px; z-index: 10;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(255, 255, 255, 0.02) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1; position: absolute; top: -100px; left: 0;
            pointer-events: none; will-change: transform;
            animation: scanline 8s linear infinite;
        }
        @keyframes scanline { 
            0% { transform: translateY(0); } 
            100% { transform: translateY(120vh); } 
        }
    </style>
</head>
<body>
    <canvas id="game-canvas"></canvas>
    <div class="scanline"></div>

    <div id="ui-layer">
        <div class="hud-panel">
            <div id="score">SCORE: 000000</div>
            <div id="highscore" style="font-size: 0.8rem; color: #888; margin-top:5px;">BEST: 000000</div>
        </div>
        <div class="hud-panel" style="align-self: flex-end; text-align: right;">
            <div id="level">SECTOR: 1</div>
            <div class="health-bar-container">
                <!-- Using scaleX for performant resizing -->
                <div id="health" class="health-fill" style="transform: scaleX(1);"></div>
            </div>
        </div>
    </div>

    <div id="start-screen" class="modal active">
        <h1>NEXUS DEFENDER</h1>
        <p>PILOT: Use <strong>WASD</strong> to Move. <strong>MOUSE</strong> to Aim & Shoot.</p>
        <button class="btn" onclick="Game.init()">INITIALIZE SYSTEM</button>
    </div>

    <div id="game-over-screen" class="modal">
        <h1 style="color: var(--neon-red);">CRITICAL FAILURE</h1>
        <p id="final-stats">SECTOR REACHED: 1</p>
        <button class="btn" onclick="Game.reset()">REBOOT SYSTEM</button>
    </div>

<script>
/* 
 * NEXUS ENGINE v4.1 (Optimized)
 * Improved Memory Management & Rendering Pipeline
 */

// --- OBJECT POOL ---
// Generic Pool to reuse objects and avoid Garbage Collection spikes
class Pool {
    constructor(createFn, resetFn, initialSize = 50) {
        this.create = createFn;
        this.reset = resetFn;
        this.store = [];
        for(let i=0; i<initialSize; i++) this.store.push(this.create());
    }
    get() {
        if(this.store.length === 0) return this.create();
        const obj = this.store.pop();
        return this.reset(obj);
    }
    release(obj) {
        this.store.push(obj);
    }
}

// --- RENDERER & CONFIG ---
const Config = {
    FRICTION: 0.92,
    PLAYER_SPEED: 0.8,
    COLORS: { PLAYER: '#00f3ff', ENEMY_1: '#ff0055', ENEMY_2: '#ff9900', BULLET: '#ffffff' }
};

// --- ENTITIES ---
class Entity {
    constructor(x, y, radius, color) {
        this.x = x; this.y = y;
        this.vx = 0; this.vy = 0;
        this.radius = radius;
        this.color = color;
        this.dead = false;
        this.hp = 1; this.maxHp = 1;
    }
    // Optimized: direct mutation, no Vec2 object creation
    update() {
        this.x += this.vx;
        this.y += this.vy;
    }
    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        ctx.closePath();
    }
}

class Particle extends Entity {
    update() {
        this.vx *= 0.95; this.vy *= 0.95;
        this.x += this.vx; this.y += this.vy;
        this.alpha -= this.life;
    }
    draw(ctx) {
        ctx.globalAlpha = Math.max(0, this.alpha);
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, 2, 0, Math.PI*2);
        ctx.fill();
        ctx.globalAlpha = 1.0;
    }
}

class Player extends Entity {
    constructor() {
        super(innerWidth/2, innerHeight/2, 10, Config.COLORS.PLAYER);
        this.hp = 100; this.maxHp = 100; this.angle = 0;
    }
    update(input) {
        // Direct physics mutation
        if (input.keys['w']) this.vy -= Config.PLAYER_SPEED;
        if (input.keys['s']) this.vy += Config.PLAYER_SPEED;
        if (input.keys['a']) this.vx -= Config.PLAYER_SPEED;
        if (input.keys['d']) this.vx += Config.PLAYER_SPEED;

        this.vx *= Config.FRICTION; this.vy *= Config.FRICTION;
        super.update();

        this.x = Math.max(this.radius, Math.min(innerWidth - this.radius, this.x));
        this.y = Math.max(this.radius, Math.min(innerHeight - this.radius, this.y));

        this.angle = Math.atan2(input.mouse.y - this.y, input.mouse.x - this.x);
    }
    draw(ctx) {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);
        ctx.beginPath();
        ctx.moveTo(15, 0); ctx.lineTo(-10, 10); ctx.lineTo(-5, 0); ctx.lineTo(-10, -10);
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 15; ctx.shadowColor = this.color;
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.restore();
    }
}

class Enemy extends Entity {
    constructor(type, level) {
        super(0, 0, 10, Config.COLORS.ENEMY_1);
        this.spawn(type, level);
    }
    spawn(type, level) {
        // Reset logic for reuse
        const edge = Math.floor(Math.random() * 4);
        if (edge === 0) { this.x = Math.random() * innerWidth; this.y = -20; }
        else if (edge === 1) { this.x = innerWidth + 20; this.y = Math.random() * innerHeight; }
        else if (edge === 2) { this.x = Math.random() * innerWidth; this.y = innerHeight + 20; }
        else { this.x = -20; this.y = Math.random() * innerHeight; }

        this.vx = 0; this.vy = 0;
        this.dead = false;

        const diff = 1 + (level * 0.1);
        if (type === 0) { this.speed = (3+Math.random())*diff; this.hp=1*diff; this.radius=10; this.color=Config.COLORS.ENEMY_1; }
        else { this.speed = (1.5+Math.random())*diff; this.hp=3*diff; this.radius=18; this.color=Config.COLORS.ENEMY_2; }
    }
    ai(px, py) {
        const dx = px - this.x;
        const dy = py - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if(dist > 0) {
            this.vx = (dx / dist) * this.speed;
            this.vy = (dy / dist) * this.speed;
        }
        super.update();
    }
}

// --- GAME MANAGER ---
const Game = {
    canvas: null, ctx: null, rafId: null,
    isRunning: false,
    score: 0, level: 1, highScore: 0,
    
    // State Cache for DOM optimization
    hudState: { score: -1, hp: -1, level: -1 },

    entities: {
        player: null,
        projectiles: [],
        enemies: [],
        particles: []
    },

    // Pools
    particlePool: null,

    input: { keys: {}, mouse: {x:0, y:0}, mouseDown: false },

    setup() {
        this.canvas = document.getElementById('game-canvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });
        
        this.particlePool = new Pool(
            () => new Particle(0,0,0,0),
            (p) => { p.alpha = 1; p.dead = false; return p; },
            200
        );

        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Input Handlers
        window.addEventListener('keydown', e => this.input.keys[e.key] = true);
        window.addEventListener('keyup', e => this.input.keys[e.key] = false);
        window.addEventListener('mousemove', e => { this.input.mouse.x = e.clientX; this.input.mouse.y = e.clientY; });
        window.addEventListener('mousedown', () => this.input.mouseDown = true);
        window.addEventListener('mouseup', () => this.input.mouseDown = false);
        
        // Persistence
        const saved = localStorage.getItem('NEXUS_SAVE');
        if(saved) this.highScore = JSON.parse(saved).highScore || 0;
    },

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
    },

    init() {
        document.querySelector('.modal.active')?.classList.remove('active');
        if (this.rafId) cancelAnimationFrame(this.rafId);
        
        this.entities.player = new Player();
        this.entities.projectiles = [];
        this.entities.enemies = [];
        // Clear particles but return to pool ideally, here just reset array for simplicity
        this.entities.particles = [];
        
        this.score = 0;
        this.level = 1;
        this.isRunning = true;
        this.hudState = { score: -1, hp: -1, level: -1 }; // Force UI update
        
        this.loop();
    },

    reset() {
        document.getElementById('game-over-screen').classList.remove('active');
        this.init();
    },

    gameOver() {
        this.isRunning = false;
        if (this.score > this.highScore) {
            this.highScore = this.score;
            localStorage.setItem('NEXUS_SAVE', JSON.stringify({ highScore: this.highScore }));
        }
        document.getElementById('final-stats').innerHTML = `SECTOR: ${this.level}<br>SCORE: ${Math.floor(this.score)}`;
        document.getElementById('game-over-screen').classList.add('active');
    },

    createExplosion(x, y, color) {
        for (let i = 0; i < 8; i++) {
            const p = this.particlePool.get();
            p.x = x; p.y = y; p.color = color;
            p.vx = (Math.random() - 0.5) * 6;
            p.vy = (Math.random() - 0.5) * 6;
            p.life = Math.random() * 0.05 + 0.02;
            this.entities.particles.push(p);
        }
    },

    updateHUD() {
        // DOM OPTIMIZATION: Only touch DOM if values changed
        const scoreFloor = Math.floor(this.score);
        if (scoreFloor !== this.hudState.score) {
            document.getElementById('score').innerText = `SCORE: ${scoreFloor.toString().padStart(6, '0')}`;
            this.hudState.score = scoreFloor;
        }
        if (this.level !== this.hudState.level) {
             document.getElementById('level').innerText = `SECTOR: ${this.level}`;
             this.hudState.level = this.level;
        }
        
        const hpPct = Math.max(0, this.entities.player.hp / this.entities.player.maxHp);
        if (Math.abs(hpPct - this.hudState.hp) > 0.01) {
             document.getElementById('health').style.transform = `scaleX(${hpPct})`;
             this.hudState.hp = hpPct;
        }
    },

    loop() {
        if (!this.isRunning) return;
        this.rafId = requestAnimationFrame(() => this.loop());

        const { ctx, canvas, entities, input } = this;
        const { player } = entities;

        // 1. Render Background
        ctx.fillStyle = 'rgba(5, 5, 5, 0.4)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // 2. Player Logic
        player.update(input);
        
        if (input.mouseDown && this.hudState.score % 5 === 0) { // Simple fire rate limit based on score tick or separate counter
            const p = new Entity(player.x + Math.cos(player.angle)*15, player.y + Math.sin(player.angle)*15, 3, Config.COLORS.BULLET);
            p.vx = Math.cos(player.angle) * 15;
            p.vy = Math.sin(player.angle) * 15;
            entities.projectiles.push(p);
            input.mouseDown = false; // Semi-auto or needs cooldown logic
        }

        // Spawning
        if (Math.random() < 0.02 + (this.level * 0.005)) {
            const type = (this.level > 3 && Math.random() > 0.7) ? 1 : 0;
            entities.enemies.push(new Enemy(type, this.level));
        }

        // 3. Entity Loop (Optimized: Reverse loops for safe deletion)
        // Projectiles
        for (let i = entities.projectiles.length - 1; i >= 0; i--) {
            const p = entities.projectiles[i];
            p.update();
            p.draw(ctx);
            if (p.x < 0 || p.x > canvas.width || p.y < 0 || p.y > canvas.height || p.dead) {
                entities.projectiles.splice(i, 1);
            }
        }

        // Enemies
        for (let i = entities.enemies.length - 1; i >= 0; i--) {
            const e = entities.enemies[i];
            e.ai(player.x, player.y);
            e.draw(ctx);

            // Collision: Player
            const distP = Math.hypot(e.x - player.x, e.y - player.y);
            if (distP < e.radius + player.radius) {
                player.hp -= 10;
                e.dead = true;
                this.createExplosion(e.x, e.y, Config.COLORS.PLAYER);
            }

            // Collision: Bullets
            for (let j = entities.projectiles.length - 1; j >= 0; j--) {
                const p = entities.projectiles[j];
                const distB = Math.hypot(e.x - p.x, e.y - p.y);
                if (distB < e.radius + p.radius) {
                    e.hp--;
                    p.dead = true;
                    this.createExplosion(p.x, p.y, '#fff');
                    if (e.hp <= 0) {
                        e.dead = true;
                        this.score += 10 * this.level;
                        this.createExplosion(e.x, e.y, e.color);
                    }
                }
            }

            if (e.dead) entities.enemies.splice(i, 1);
        }

        // Particles ( pooled )
        for (let i = entities.particles.length - 1; i >= 0; i--) {
            const p = entities.particles[i];
            p.update();
            p.draw(ctx);
            if (p.alpha <= 0) {
                this.particlePool.release(p);
                entities.particles.splice(i, 1);
            }
        }

        if (this.score > this.level * 1000) this.level++;
        if (player.hp <= 0) this.gameOver();
        else player.draw(ctx);

        this.updateHUD();
    }
};

window.onload = () => Game.setup();
</script>
</body>
</html>
