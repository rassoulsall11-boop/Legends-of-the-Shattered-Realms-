```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS // BLOCK BLAST [ENTERPRISE EDITION]</title>
    <style>
        :root {
            --bg-primary: #0f172a;
            --bg-secondary: #1e293b;
            --accent-primary: #3b82f6;
            --accent-secondary: #8b5cf6;
            --text-primary: #f8fafc;
            --font-stack: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; user-select: none; -webkit-user-select: none; }

        body {
            background-color: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-stack);
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 600px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        canvas {
            border-radius: 12px;
            box-shadow: 0 20px 50px -12px rgba(0, 0, 0, 0.5);
        }

        .ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .score-box {
            background: rgba(30, 41, 59, 0.9);
            backdrop-filter: blur(10px);
            padding: 1rem 1.5rem;
            border-radius: 16px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            text-align: center;
        }

        .score-label { font-size: 0.75rem; text-transform: uppercase; letter-spacing: 0.1em; color: #94a3b8; }
        .score-value { font-size: 1.5rem; font-weight: 800; background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary)); -webkit-background-clip: text; -webkit-text-fill-color: transparent; }

        #modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
        }

        #modal-overlay.active { opacity: 1; pointer-events: auto; }

        .modal-content {
            background: var(--bg-secondary);
            padding: 2.5rem;
            border-radius: 24px;
            text-align: center;
            border: 1px solid rgba(255,255,255,0.05);
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }

        #modal-overlay.active .modal-content { transform: scale(1); }

        h1 { font-size: 2.5rem; margin-bottom: 0.5rem; font-weight: 900; }
        p { color: #94a3b8; margin-bottom: 2rem; }

        button {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            border: none;
            padding: 1rem 3rem;
            color: white;
            font-size: 1.1rem;
            font-weight: 700;
            border-radius: 12px;
            cursor: pointer;
            transition: transform 0.1s, box-shadow 0.2s;
            box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.4);
        }

        button:active { transform: scale(0.96); }

    </style>
</head>
<body>

<div id="game-container">
    <div class="ui-layer">
        <div class="hud-top">
            <div class="score-box">
                <div class="score-label">Best</div>
                <div class="score-value" id="best-score">0</div>
            </div>
            <div class="score-box">
                <div class="score-label">Score</div>
                <div class="score-value" id="current-score">0</div>
            </div>
        </div>
    </div>
    <canvas id="gameCanvas"></canvas>
    
    <div id="modal-overlay" class="active">
        <div class="modal-content">
            <h1 id="modal-title">BLOCK BLAST</h1>
            <p id="modal-msg">Nexus Engine Ready.</p>
            <button id="start-btn">INITIALIZE</button>
        </div>
    </div>
</div>

<script>
/**
 * NEXUS ARCHITECT v4.0 - INDUSTRIAL GRADE GAME ENGINE
 * Pattern: Entity-Component-System (Hybrid) / Singleton State Manager
 * Performance: Canvas API with double buffering simulation logic
 */

// --- CONSTANTS & CONFIGURATION ---
const CONFIG = {
    GRID_SIZE: 8,
    CELL_GAP: 4,
    ANIMATION_SPEED: 0.15, // Seconds
    COLORS: [
        '#ef4444', // Red
        '#f59e0b', // Amber
        '#10b981', // Emerald
        '#3b82f6', // Blue
        '#8b5cf6', // Violet
        '#ec4899'  // Pink
    ],
    BG_GRID_COLOR: '#334155',
    SHAPES: [
        [[1]], [[1,1]], [[1,1,1]], [[1,1,1,1]], // Lines
        [[1],[1]], [[1],[1],[1]], [[1],[1],[1],[1]], // Columns
        [[1,1],[1,1]], // Square
        [[1,0],[1,0],[1,1]], [[0,1],[0,1],[1,1]], // L shapes
        [[1,1,1],[0,1,0]], [[0,1,0],[1,1,1]], // T shapes
        [[1,1,0],[0,1,1]], [[0,1,1],[1,1,0]] // Z shapes
    ]
};

// --- UTILS ---
const Utils = {
    randomInt: (min, max) => Math.floor(Math.random() * (max - min + 1) + min),
    lerp: (start, end, t) => start * (1 - t) + end * t,
    isMobile: () => /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
    getDPR: () => window.devicePixelRatio || 1
};

// --- AUDIO SYSTEM (Synthesized for performance/no assets) ---
class AudioController {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.enabled = true;
    }

    playTone(freq, type, duration, vol = 0.1) {
        if (!this.enabled) return;
        if (this.ctx.state === 'suspended') this.ctx.resume();
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.ctx.destination);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playPlace() { this.playTone(400, 'sine', 0.1); }
    playClear() { this.playTone(800, 'triangle', 0.3, 0.2); }
    playGameOver() { this.playTone(150, 'sawtooth', 0.8, 0.3); }
}

// --- PARTICLE SYSTEM (Object Pooling) ---
class Particle {
    constructor() { this.reset(); }
    reset() {
        this.x = 0; this.y = 0; this.vx = 0; this.vy = 0;
        this.life = 0; this.maxLife = 0; this.color = '#fff';
        this.size = 0; this.active = false;
    }
}

class ParticleSystem {
    constructor(limit = 100) {
        this.pool = Array.from({ length: limit }, () => new Particle());
        this.activeParticles = [];
    }

    spawn(x, y, color) {
        const p = this.pool.find(p => !p.active);
        if (!p) return;

        p.active = true;
        p.x = x;
        p.y = y;
        const angle = Math.random() * Math.PI * 2;
        const speed = Math.random() * 4 + 2;
        p.vx = Math.cos(angle) * speed;
        p.vy = Math.sin(angle) * speed;
        p.life = 1.0;
        p.maxLife = 1.0;
        p.color = color;
        p.size = Math.random() * 5 + 2;
        this.activeParticles.push(p);
    }

    update() {
        for (let i = this.activeParticles.length - 1; i >= 0; i--) {
            const p = this.activeParticles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.vy += 0.2; // Gravity
            p.life -= 0.03;
            p.size *= 0.95;

            if (p.life <= 0) {
                p.active = false;
                this.activeParticles.splice(i, 1);
            }
        }
    }

    draw(ctx) {
        ctx.save();
        this.activeParticles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
            ctx.fill();
        });
        ctx.restore();
    }
}

// --- CORE GAME ENGINE ---
class GameEngine {
    constructor() {
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false }); // Optimize for non-transparent canvas
        
        // State
        this.grid = []; // 8x8 array
        this.hand = [null, null, null]; // The 3 shapes available
        this.score = 0;
        this.bestScore = parseInt(localStorage.getItem('nexus_block_best') || '0');
        this.state = 'MENU'; // MENU, PLAYING, GAMEOVER
        
        // Layout metrics (calculated on resize)
        this.metrics = {
            width: 0, height: 0,
            gridSize: 0, cellSize: 0, gridX: 0, gridY: 0,
            handY: 0, handZoneHeight: 0
        };

        // Interaction
        this.dragState = {
            active: false,
            shapeIndex: -1,
            shape: null, // Copy of the shape data
            visualX: 0, visualY: 0,
            offsetX: 0, offsetY: 0,
            targetGridX: -1, targetGridY: -1
        };

        // Systems
        this.audio = new AudioController();
        this.particles = new ParticleSystem();

        this.init();
    }

    init() {
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Event Listeners (Unified Pointer Events)
        this.canvas.addEventListener('pointerdown', e => this.handleInputStart(e));
        window.addEventListener('pointermove', e => this.handleInputMove(e));
        window.addEventListener('pointerup', e => this.handleInputEnd(e));

        // UI Bindings
        document.getElementById('start-btn').addEventListener('click', () => this.startGame());

        // Update DOM
        this.updateScoreUI();

        // Loop
        requestAnimationFrame(t => this.loop(t));
    }

    resize() {
        const dpr = Utils.getDPR();
        const container = document.getElementById('game-container');
        const rect = container.getBoundingClientRect();
        
        this.canvas.width = rect.width * dpr;
        this.canvas.height = rect.height * dpr;
        
        this.ctx.scale(dpr, dpr);
        this.canvas.style.width = `${rect.width}px`;
        this.canvas.style.height = `${rect.height}px`;

        this.metrics.width = rect.width;
        this.metrics.height = rect.height;

        // Calculate layout
        const safeMargin = 20;
        const availableWidth = this.metrics.width - (safeMargin * 2);
        
        // Grid logic
        this.metrics.cellSize = Math.floor(availableWidth / CONFIG.GRID_SIZE);
        this.metrics.gridSize = this.metrics.cellSize * CONFIG.GRID_SIZE;
        this.metrics.gridX = safeMargin + (availableWidth - this.metrics.gridSize) / 2;
        this.metrics.gridY = this.metrics.height * 0.15; // Top 15% padding

        // Hand logic
        this.metrics.handY = this.metrics.gridY + this.metrics.gridSize + 40;
        this.metrics.handZoneHeight = this.metrics.height - this.metrics.handY;
    }

    startGame() {
        // Reset Grid
        this.grid = Array(CONFIG.GRID_SIZE).fill().map(() => Array(CONFIG.GRID_SIZE).fill(null));
        this.score = 0;
        this.updateScoreUI();
        this.state = 'PLAYING';
        this.spawnHand();
        
        document.getElementById('modal-overlay').classList.remove('active');
        this.audio.playPlace();
    }

    spawnHand() {
        // Create 3 new shapes
        for (let i = 0; i < 3; i++) {
            const shapeDef = CONFIG.SHAPES[Utils.randomInt(0, CONFIG.SHAPES.length - 1)];
            const color = CONFIG.COLORS[Utils.randomInt(0, CONFIG.COLORS.length - 1)];
            
            // Deep copy shape matrix
            this.hand[i] = {
                matrix: shapeDef,
                color: color,
                scale: 0.6, // Smaller in hand
                x: 0, y: 0, // Calculated in render
                width: shapeDef[0].length,
                height: shapeDef.length
            };
        }
        
        if (this.checkGameOver()) {
            this.triggerGameOver();
        }
    }

    // --- LOGIC: PLACEMENT & CLEARING ---

    canPlace(shapeMatrix, gridX, gridY) {
        const h = shapeMatrix.length;
        const w = shapeMatrix[0].length;

        // Boundary check
        if (gridX < 0 || gridX + w > CONFIG.GRID_SIZE || gridY < 0 || gridY + h > CONFIG.GRID_SIZE) {
            return false;
        }

        // Collision check
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (shapeMatrix[y][x] === 1) {
                    if (this.grid[gridY + y][gridX + x] !== null) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    placeShape(shapeMatrix, gridX, gridY, color) {
        const h = shapeMatrix.length;
        const w = shapeMatrix[0].length;

        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                if (shapeMatrix[y][x] === 1) {
                    this.grid[gridY + y][gridX + x] = color;
                    // Visual fx
                    const worldX = this.metrics.gridX + (gridX + x) * this.metrics.cellSize + this.metrics.cellSize/2;
                    const worldY = this.metrics.gridY + (gridY + y) * this.metrics.cellSize + this.metrics.cellSize/2;
                    this.particles.spawn(worldX, worldY, color);
                }
            }
        }
        
        this.audio.playPlace();
        this.hand[this.dragState.shapeIndex] = null;
        this.checkClears();
        
        // Check if hand needs refill
        if (this.hand.every(s => s === null)) {
            setTimeout(() => this.spawnHand(), 200);
        } else {
            if (this.checkGameOver()) this.triggerGameOver();
        }
    }

    checkClears() {
        let rowsToClear = [];
        let colsToClear = [];

        // Check Rows
        for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
            if (this.grid[y].every(cell => cell !== null)) rowsToClear.push(y);
        }

        // Check Cols
        for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
            let full = true;
            for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
                if (this.grid[y][x] === null) full = false;
            }
            if (full) colsToClear.push(x);
        }

        if (rowsToClear.length > 0 || colsToClear.length > 0) {
            this.audio.playClear();
            const basePoints = 10;
            const comboMultiplier = rowsToClear.length + colsToClear.length;
            this.score += (basePoints * comboMultiplier * comboMultiplier); // Exponential scoring for combos
            this.updateScoreUI();

            // Clear logic
            rowsToClear.forEach(y => {
                for(let x=0; x<CONFIG.GRID_SIZE; x++) {
                    this.spawnExplosion(x, y, this.grid[y][x]);
                    this.grid[y][x] = null;
                }
            });
            colsToClear.forEach(x => {
                for(let y=0; y<CONFIG.GRID_SIZE; y++) {
                    if (this.grid[y][x] !== null) { // Prevent double clear issues
                        this.spawnExplosion(x, y, this.grid[y][x]);
                        this.grid[y][x] = null;
                    }
                }
            });
        }
    }

    spawnExplosion(gridX, gridY, color) {
        const cx = this.metrics.gridX + gridX * this.metrics.cellSize + this.metrics.cellSize/2;
        const cy = this.metrics.gridY + gridY * this.metrics.cellSize + this.metrics.cellSize/2;
        for(let i=0; i<5; i++) this.particles.spawn(cx, cy, color);
    }

    checkGameOver() {
        // Iterate available shapes
        for (let i = 0; i < 3; i++) {
            const shape = this.hand[i];
            if (!shape) continue;

            // Brute force check: can this shape fit ANYWHERE?
            for (let y = 0; y < CONFIG.GRID_SIZE; y++) {
                for (let x = 0; x < CONFIG.GRID_SIZE; x++) {
                    if (this.canPlace(shape.matrix, x, y)) return false;
                }
            }
        }
        return true; // No moves left
    }

    triggerGameOver() {
        this.state = 'GAMEOVER';
        this.audio.playGameOver();
        if (this.score > this.bestScore) {
            this.bestScore = this.score;
            localStorage.setItem('nexus_block_best', this.bestScore);
        }
        
        const modal = document.getElementById('modal-overlay');
        document.getElementById('modal-title').innerText = "SYSTEM FAILURE";
        document.getElementById('modal-msg').innerText = `Final Score: ${this.score}`;
        document.getElementById('start-btn').innerText = "REBOOT SYSTEM";
        modal.classList.add('active');
    }

    updateScoreUI() {
        document.getElementById('current-score').innerText = this.score;
        document.getElementById('best-score').innerText = this.bestScore;
    }

    // --- INPUT HANDLING ---
    handleInputStart(e) {
        if (this.state !== 'PLAYING') return;

        const rect = this.canvas.getBoundingClientRect();
        const x = (e.clientX - rect.left);
        const y = (e.clientY - rect.top);

        // Check if clicked a hand shape
        const slotWidth = this.metrics.width / 3;
        
        for (let i = 0; i < 3; i++) {
            if (!this.hand[i]) continue;
            
            // Hitbox approximation
            const centerX = (i * slotWidth) + (slotWidth / 2);
            const centerY = this.metrics.handY + 60;
            const dist = Math.hypot(x - centerX, y - centerY);

            if (dist < 60) { // Hit radius
                this.dragState.active = true;
                this.dragState.shapeIndex = i;
                this.dragState.shape = this.hand[i];
                this.dragState.visualX = x;
                this.dragState.visualY = y;
                // Offset so we drag from center of shape
                this.dragState.offsetX = 0; 
                this.dragState.offsetY = -80; // Lift it up slightly so finger doesn't cover it
            }
        }
    }

    handleInputMove(e) {
        if (!this.dragState.active) return;
        
        const rect = this.canvas.getBoundingClientRect();
        this.dragState.visualX = (e.clientX - rect.left);
        this.dragState.visualY = (e.clientY - rect.top);

        // Snap Calculation
        const shape = this.dragState.shape;
        const cellSize = this.metrics.cellSize;
        
        // Calculate shape center in pixels
        const shapePixelW = shape.width * cellSize;
        const shapePixelH = shape.height * cellSize;
        
        const testX = this.dragState.visualX + this.dragState.offsetX - (shapePixelW / 2);
        const testY = this.dragState.visualY + this.dragState.offsetY - (shapePixelH / 2);

        // Convert to grid coords
        const gx = Math.round((testX - this.metrics.gridX) / cellSize);
        const gy = Math.round((testY - this.metrics.gridY) / cellSize);

        this.dragState.targetGridX = gx;


