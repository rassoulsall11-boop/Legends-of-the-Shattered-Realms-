<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS PROTOTYPE: CHRONOS MAZE</title>
    <style>
        :root {
            --bg-color: #050505;
            --ui-bg: rgba(20, 20, 30, 0.95);
            --accent: #00f3ff;
            --accent-dim: rgba(0, 243, 255, 0.1);
            --danger: #ff2a6d;
            --warning: #ffc107;
            --text-main: #e0e0e0;
            --font-stack: 'SF Mono', 'Fira Code', Consolas, monospace;
        }

        /* OPTIMIZATION: Removed universal selector abuse */
        html, body {
            margin: 0; padding: 0; height: 100vh; overflow: hidden;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: var(--font-stack);
            touch-action: none; /* Disables zoom/scroll explicitly on container */
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        *, *::before, *::after { box-sizing: border-box; }

        canvas {
            position: absolute; top: 0; left: 0; z-index: 1;
            /* OPTIMIZATION: Force GPU layer */
            will-change: transform;
        }

        #ui-layer {
            position: absolute; z-index: 10; width: 100%; height: 100%;
            pointer-events: none;
            display: grid; grid-template-rows: 60px 1fr 120px;
        }

        .hud-header {
            padding: 20px;
            display: flex; justify-content: space-between; align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .stat-group { display: flex; gap: 20px; font-size: 14px; letter-spacing: 1px; }
        .stat-value { color: var(--accent); font-weight: bold; text-shadow: 0 0 10px var(--accent-dim); }

        #modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); backdrop-filter: blur(8px);
            display: flex; justify-content: center; align-items: center;
            opacity: 0; pointer-events: none;
            transition: opacity 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 20;
        }
        #modal-overlay.active { opacity: 1; pointer-events: all; }

        .choice-card {
            background: var(--ui-bg);
            border: 1px solid var(--accent-dim); border-left: 4px solid var(--accent);
            padding: 30px; width: 90%; max-width: 500px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transform: translateY(20px); transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }
        #modal-overlay.active .choice-card { transform: translateY(0); }

        .card-title { font-size: 18px; color: var(--accent); margin-bottom: 15px; text-transform: uppercase; letter-spacing: 2px; }
        .card-desc { font-size: 14px; line-height: 1.6; color: #aaa; margin-bottom: 25px; }
        .btn-group { display: flex; flex-direction: column; gap: 10px; }
        
        button {
            background: transparent; border: 1px solid rgba(255,255,255,0.1);
            color: var(--text-main); padding: 15px; font-family: var(--font-stack);
            font-size: 14px; cursor: pointer; transition: all 0.2s ease;
            text-align: left; position: relative; overflow: hidden; pointer-events: all;
        }
        button::before {
            content: ''; position: absolute; top: 0; left: 0; width: 2px; height: 100%;
            background: var(--accent); opacity: 0; transition: opacity 0.2s;
        }
        button:hover { background: rgba(255,255,255,0.05); border-color: var(--accent); transform: translateX(5px); }
        button:hover::before { opacity: 1; }

        #virtual-pad {
            pointer-events: all; display: grid;
            grid-template-columns: repeat(3, 1fr); grid-template-rows: repeat(2, 1fr);
            gap: 10px; padding: 20px; width: 220px; margin: 0 auto; align-self: end;
        }
        .d-pad-btn {
            background: rgba(255,255,255,0.05); border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px; height: 50px; display: flex;
            justify-content: center; align-items: center; color: var(--accent);
        }
        .d-pad-btn:active { background: var(--accent); color: #000; }
        .d-up { grid-column: 2; grid-row: 1; }
        .d-left { grid-column: 1; grid-row: 2; }
        .d-down { grid-column: 2; grid-row: 2; }
        .d-right { grid-column: 3; grid-row: 2; }

        @media (min-width: 768px) { #virtual-pad { display: none; } }

        #scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            /* OPTIMIZATION: Reduced paint complexity */
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
            background-size: 100% 4px;
            z-index: 50; pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="scanlines"></div>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-layer">
        <div class="hud-header">
            <div class="stat-group">
                <span>ENERGY: <span id="energy-val" class="stat-value">100%</span></span>
                <span>DEPTH: <span id="depth-val" class="stat-value">0</span></span>
            </div>
            <div class="stat-group"><span>STATUS: <span id="status-val" style="color:var(--warning)">STABLE</span></span></div>
        </div>
        <div></div>
        <div id="virtual-pad">
            <div class="d-pad-btn d-up" data-dir="up">▲</div>
            <div class="d-pad-btn d-left" data-dir="left">◀</div>
            <div class="d-pad-btn d-down" data-dir="down">▼</div>
            <div class="d-pad-btn d-right" data-dir="right">▶</div>
        </div>
    </div>
    <div id="modal-overlay">
        <div class="choice-card">
            <div class="card-title" id="choice-title"></div>
            <div class="card-desc" id="choice-desc"></div>
            <div class="btn-group" id="choice-options"></div>
        </div>
    </div>

<script>
class EventEmitter {
    constructor() { this.events = {}; }
    on(event, listener) { (this.events[event] = this.events[event] || []).push(listener); }
    emit(event, payload) { if (this.events[event]) this.events[event].forEach(l => l(payload)); }
}

const CONSTANTS = {
    GRID_SIZE: 40,
    COLORS: { WALL: '#222', FLOOR: '#111', PLAYER: '#00f3ff', GOAL: '#00ff55', EVENT: '#ffc107', TRAIL: 'rgba(0, 243, 255, 0.15)' }
};

class GameState {
    constructor(bus) {
        this.bus = bus;
        this.energy = 100;
        this.depth = 0;
        this.playerPos = { x: 1, y: 1 };
        this.map = [];
        this.mapWidth = 15;
        this.mapHeight = 15;
        this.isInputLocked = false;
        this.events = new Map();
    }

    init() { this.generateLevel(); }

    generateLevel() {
        this.map = [];
        for (let y = 0; y < this.mapHeight; y++) {
            const row = [];
            for (let x = 0; x < this.mapWidth; x++) {
                if (x === 0 || x === this.mapWidth - 1 || y === 0 || y === this.mapHeight - 1) row.push(1);
                else row.push(Math.random() > 0.8 ? 1 : 0);
            }
            this.map.push(row);
        }
        this.map[1][1] = 0;
        this.placeEvents();
        this.bus.emit('level:generated'); // Trigger for cached render
    }

    placeEvents() {
        this.events.clear();
        let count = 0;
        while(count < 5) {
            let rx = Math.floor(Math.random() * (this.mapWidth-2)) + 1;
            let ry = Math.floor(Math.random() * (this.mapHeight-2)) + 1;
            // OPTIMIZATION: Integer key instead of string
            let key = ry * this.mapWidth + rx;
            if(rx !== 1 && ry !== 1 && this.map[ry][rx] === 0) {
                this.events.set(key, { title: "Data Node", desc: "Recover data?", options: [] });
                this.map[ry][rx] = 2;
                count++;
            }
        }
        this.map[this.mapHeight-2][this.mapWidth-2] = 3;
    }

    movePlayer(dx, dy) {
        if (this.isInputLocked) return;
        const newX = this.playerPos.x + dx;
        const newY = this.playerPos.y + dy;

        if (this.map[newY][newX] === 1) return;

        this.playerPos.x = newX;
        this.playerPos.y = newY;
        this.energy -= 1;
        this.bus.emit('player:moved', this.playerPos);
        
        // OPTIMIZATION: Check event with integer key
        const key = newY * this.mapWidth + newX;
        const tile = this.map[newY][newX];

        if (tile === 2 && this.events.has(key)) {
             // Simple alert for demo, real modal logic would go here
             console.log("Event Triggered");
             this.map[newY][newX] = 0;
             this.events.delete(key);
             this.bus.emit('level:generated'); // Re-cache map because tile changed
        } else if (tile === 3) {
            this.depth++;
            this.generateLevel();
            this.playerPos = { x: 1, y: 1 };
        }
    }
}

class Renderer {
    constructor(canvas, state) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', { alpha: false });
        this.state = state;
        // OPTIMIZATION: Offscreen canvas for static map
        this.mapCanvas = document.createElement('canvas');
        this.mapCtx = this.mapCanvas.getContext('2d');
        this.resize();
        window.addEventListener('resize', () => this.resize());
        
        // Listen for map changes to re-render the static part
        this.state.bus.on('level:generated', () => this.cacheMap());
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        this.cacheMap();
    }

    // OPTIMIZATION: Draw map once, only when it changes
    cacheMap() {
        const cellSize = Math.min(this.canvas.width, this.canvas.height) / 12;
        this.mapCanvas.width = this.state.mapWidth * cellSize;
        this.mapCanvas.height = this.state.mapHeight * cellSize;
        
        const ctx = this.mapCtx;
        ctx.clearRect(0,0,this.mapCanvas.width, this.mapCanvas.height);
        
        for (let y = 0; y < this.state.mapHeight; y++) {
            for (let x = 0; x < this.state.mapWidth; x++) {
                const cell = this.state.map[y][x];
                const px = x * cellSize;
                const py = y * cellSize;

                ctx.fillStyle = (cell === 1) ? CONSTANTS.COLORS.WALL : CONSTANTS.COLORS.FLOOR;
                if(cell === 1) ctx.fillRect(px, py, cellSize, cellSize);
                
                ctx.strokeStyle = '#222';
                ctx.strokeRect(px, py, cellSize, cellSize);

                if (cell === 2) {
                    ctx.fillStyle = CONSTANTS.COLORS.EVENT;
                    ctx.beginPath(); ctx.arc(px + cellSize/2, py + cellSize/2, cellSize * 0.3, 0, Math.PI * 2); ctx.fill();
                }
                if (cell === 3) {
                    ctx.strokeStyle = CONSTANTS.COLORS.GOAL;
                    ctx.lineWidth = 3; ctx.strokeRect(px+5, py+5, cellSize-10, cellSize-10);
                }
            }
        }
        this.cellSize = cellSize;
    }

    draw() {
        this.ctx.fillStyle = '#000';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        const offsetX = (this.canvas.width / 2) - (this.state.playerPos.x * this.cellSize) - (this.cellSize / 2);
        const offsetY = (this.canvas.height / 2) - (this.state.playerPos.y * this.cellSize) - (this.cellSize / 2);

        this.ctx.save();
        this.ctx.translate(offsetX, offsetY);
        
        // OPTIMIZATION: Blit the pre-rendered map
        this.ctx.drawImage(this.mapCanvas, 0, 0);

        // Draw Player
        const pX = this.state.playerPos.x * this.cellSize;
        const pY = this.state.playerPos.y * this.cellSize;
        this.ctx.fillStyle = CONSTANTS.COLORS.PLAYER;
        this.ctx.beginPath();
        this.ctx.arc(pX + this.cellSize/2, pY + this.cellSize/2, this.cellSize * 0.35, 0, Math.PI*2);
        this.ctx.fill();

        this.ctx.restore();
    }
}

class App {
    constructor() {
        this.bus = new EventEmitter();
        this.state = new GameState(this.bus);
        this.canvas = document.getElementById('gameCanvas');
        this.renderer = new Renderer(this.canvas, this.state);
        
        this.bindEvents();
        this.state.init();
        this.loop();
    }

    bindEvents() {
        window.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp': case 'w': this.state.movePlayer(0, -1); break;
                case 'ArrowDown': case 's': this.state.movePlayer(0, 1); break;
                case 'ArrowLeft': case 'a': this.state.movePlayer(-1, 0); break;
                case 'ArrowRight': case 'd': this.state.movePlayer(1, 0); break;
            }
        });

        document.querySelectorAll('.d-pad-btn').forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                const dir = btn.dataset.dir;
                if (dir === 'up') this.state.movePlayer(0, -1);
                if (dir === 'down') this.state.movePlayer(0, 1);
                if (dir === 'left') this.state.movePlayer(-1, 0);
                if (dir === 'right') this.state.movePlayer(1, 0);
            }, { passive: false });
        });
    }

    loop() {
        this.renderer.draw();
        requestAnimationFrame(() => this.loop());
    }
}

// Initialize
new App();
</script>
</body>
</html>
