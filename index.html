```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEXUS PROTOTYPE: CHRONOS MAZE</title>
    <style>
        :root {
            --bg-color: #050505;
            --ui-bg: rgba(20, 20, 30, 0.95);
            --accent: #00f3ff;
            --accent-dim: rgba(0, 243, 255, 0.1);
            --danger: #ff2a6d;
            --warning: #ffc107;
            --text-main: #e0e0e0;
            --font-stack: 'SF Mono', 'Fira Code', Consolas, monospace;
        }

        * { box-sizing: border-box; touch-action: none; user-select: none; -webkit-font-smoothing: antialiased; }
        
        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            font-family: var(--font-stack);
            overflow: hidden;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* CANVAS LAYER */
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* UI LAYER */
        #ui-layer {
            position: absolute;
            z-index: 10;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: grid;
            grid-template-rows: 60px 1fr 120px;
        }

        .hud-header {
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
        }

        .stat-group { display: flex; gap: 20px; font-size: 14px; letter-spacing: 1px; }
        .stat-value { color: var(--accent); font-weight: bold; text-shadow: 0 0 10px var(--accent-dim); }

        /* MODAL SYSTEM */
        #modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(8px);
            display: flex;
            justify-content: center;
            align-items: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s cubic-bezier(0.16, 1, 0.3, 1);
            z-index: 20;
        }

        #modal-overlay.active { opacity: 1; pointer-events: all; }

        .choice-card {
            background: var(--ui-bg);
            border: 1px solid var(--accent-dim);
            border-left: 4px solid var(--accent);
            padding: 30px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            transform: translateY(20px);
            transition: transform 0.4s cubic-bezier(0.16, 1, 0.3, 1);
        }

        #modal-overlay.active .choice-card { transform: translateY(0); }

        .card-title { font-size: 18px; color: var(--accent); margin-bottom: 15px; text-transform: uppercase; letter-spacing: 2px; }
        .card-desc { font-size: 14px; line-height: 1.6; color: #aaa; margin-bottom: 25px; }

        .btn-group { display: flex; flex-direction: column; gap: 10px; }
        
        button {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.1);
            color: var(--text-main);
            padding: 15px;
            font-family: var(--font-stack);
            font-size: 14px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-align: left;
            position: relative;
            overflow: hidden;
            pointer-events: all;
        }

        button::before {
            content: ''; position: absolute; top: 0; left: 0; width: 2px; height: 100%;
            background: var(--accent); opacity: 0; transition: opacity 0.2s;
        }

        button:hover { background: rgba(255,255,255,0.05); border-color: var(--accent); transform: translateX(5px); }
        button:hover::before { opacity: 1; }
        button.danger:hover { border-color: var(--danger); }
        button.danger::before { background: var(--danger); }

        /* CONTROLS (Mobile) */
        #virtual-pad {
            pointer-events: all;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            padding: 20px;
            width: 220px;
            margin: 0 auto;
            align-self: end;
        }

        .d-pad-btn {
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 4px;
            height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: var(--accent);
        }
        
        .d-pad-btn:active { background: var(--accent); color: #000; }
        .d-up { grid-column: 2; grid-row: 1; }
        .d-left { grid-column: 1; grid-row: 2; }
        .d-down { grid-column: 2; grid-row: 2; }
        .d-right { grid-column: 3; grid-row: 2; }

        @media (min-width: 768px) { #virtual-pad { display: none; } } /* Hide on Desktop */

        #scanlines {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%;
            z-index: 50; pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="scanlines"></div>
    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-header">
            <div class="stat-group">
                <span>ENERGY: <span id="energy-val" class="stat-value">100%</span></span>
                <span>DEPTH: <span id="depth-val" class="stat-value">0</span></span>
            </div>
            <div class="stat-group">
                <span>STATUS: <span id="status-val" style="color:var(--warning)">STABLE</span></span>
            </div>
        </div>
        
        <!-- Center Spacer -->
        <div></div>

        <!-- Virtual Controls for Mobile -->
        <div id="virtual-pad">
            <div class="d-pad-btn d-up" data-dir="up">▲</div>
            <div class="d-pad-btn d-left" data-dir="left">◀</div>
            <div class="d-pad-btn d-down" data-dir="down">▼</div>
            <div class="d-pad-btn d-right" data-dir="right">▶</div>
        </div>
    </div>

    <!-- CHOICE MODAL -->
    <div id="modal-overlay">
        <div class="choice-card">
            <div class="card-title" id="choice-title">Unknown Signal</div>
            <div class="card-desc" id="choice-desc">You encounter a flickering terminal. The data stream is corrupted but offers two paths.</div>
            <div class="btn-group" id="choice-options">
                <!-- Injected via JS -->
            </div>
        </div>
    </div>

<script>
/**
 * NEXUS ARCHITECT v4.0
 * Project: Chronos Maze (Le Labyrinthe des Choix)
 * Architecture: ECS Hybrid + Event Bus
 * Performance: O(1) Lookup, Canvas Hardware Acceleration
 */

// --- 1. CORE UTILITIES (Industrial Patterns) ---

class EventEmitter {
    constructor() { this.events = {}; }
    on(event, listener) {
        if (!this.events[event]) this.events[event] = [];
        this.events[event].push(listener);
    }
    emit(event, payload) {
        if (this.events[event]) this.events[event].forEach(l => l(payload));
    }
}

const CONSTANTS = {
    GRID_SIZE: 40,
    VIEWPORT_W: 0, 
    VIEWPORT_H: 0,
    COLORS: {
        WALL: '#222',
        FLOOR: '#111',
        PLAYER: '#00f3ff',
        GOAL: '#00ff55',
        EVENT: '#ffc107',
        TRAIL: 'rgba(0, 243, 255, 0.15)'
    }
};

// --- 2. AUDIO ENGINE (Procedural Synthesis - No Assets Needed) ---
class AudioEngine {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.3;
        this.master.connect(this.ctx.destination);
    }

    playTone(freq, type, duration, detune = 0) {
        if(this.ctx.state === 'suspended') this.ctx.resume();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.detune.value = detune;
        
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.master);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    playMove() { this.playTone(150, 'triangle', 0.1); }
    playError() { this.playTone(60, 'sawtooth', 0.3, -50); }
    playEvent() { 
        this.playTone(440, 'sine', 0.5); 
        setTimeout(() => this.playTone(554, 'sine', 0.5), 100);
    }
}

// --- 3. GAME STATE MANAGEMENT ---
class GameState {
    constructor(bus) {
        this.bus = bus;
        this.energy = 100;
        this.depth = 0;
        this.inventory = [];
        this.playerPos = { x: 1, y: 1 };
        this.map = [];
        this.mapWidth = 15;
        this.mapHeight = 15;
        this.isInputLocked = false;
        
        // Procedural Seeds
        this.chaosFactor = 0; // Increases as you make risky choices
    }

    init() {
        this.generateLevel();
    }

    generateLevel() {
        // Recursive Backtracker or Cellular Automata could go here.
        // Using a modified Prims algorithm for "Industrial" maze generation.
        this.map = [];
        for (let y = 0; y < this.mapHeight; y++) {
            const row = [];
            for (let x = 0; x < this.mapWidth; x++) {
                // Borders are walls, inside is potential
                if (x === 0 || x === this.mapWidth - 1 || y === 0 || y === this.mapHeight - 1) {
                    row.push(1); // Wall
                } else {
                    row.push(Math.random() > 0.8 ? 1 : 0); // Sparse walls
                }
            }
            this.map.push(row);
        }
        // Force start position
        this.map[1][1] = 0;
        this.placeEvents();
    }

    placeEvents() {
        this.events = new Map(); // Key: "x,y", Value: EventObject
        let count = 0;
        while(count < 5) {
            let rx = Math.floor(Math.random() * (this.mapWidth-2)) + 1;
            let ry = Math.floor(Math.random() * (this.mapHeight-2)) + 1;
            if(rx !== 1 && ry !== 1 && this.map[ry][rx] === 0) {
                this.events.set(`${rx},${ry}`, this.generateEventData());
                this.map[ry][rx] = 2; // Event marker
                count++;
            }
        }
        // Exit
        this.map[this.mapHeight-2][this.mapWidth-2] = 3; 
    }

    generateEventData() {
        const scenarios = [
            {
                title: "Corrupted Data Cache",
                desc: "You find a data shard emitting heat. It could restore energy or corrupt your map.",
                options: [
                    { label: "Extract Data (Risk)", action: 'risk_energy' },
                    { label: "Destroy It (Safe)", action: 'safe' }
                ]
            },
            {
                title: "Spatial Rift",
                desc: "The walls here are shifting. You can force a shortcut.",
                options: [
                    { label: "Force Passage (-10 Energy)", action: 'shortcut' },
                    { label: "Wait it out (-2 Energy)", action: 'wait' }
                ]
            }
        ];
        return scenarios[Math.floor(Math.random() * scenarios.length)];
    }

    movePlayer(dx, dy) {
        if (this.isInputLocked) return;
        
        const newX = this.playerPos.x + dx;
        const newY = this.playerPos.y + dy;

        // Collision Check
        if (this.map[newY][newX] === 1) {
            this.bus.emit('audio:error');
            // Slight visual shake effect handled by renderer
            return;
        }

        this.playerPos.x = newX;
        this.playerPos.y = newY;
        this.energy -= 1; // Movement cost
        this.bus.emit('player:moved', this.playerPos);
        this.bus.emit('audio:move');
        this.checkTile();

        if (this.energy <= 0) this.bus.emit('game:over', 'energy');
    }

    checkTile() {
        const tileType = this.map[this.playerPos.y][this.playerPos.x];
        
        // 2 = Event
        if (tileType === 2) {
            const key = `${this.playerPos.x},${this.playerPos.y}`;
            if (this.events.has(key)) {
                this.bus.emit('event:trigger', this.events.get(key));
                this.map[this.playerPos.y][this.playerPos.x] = 0; // Clear event
                this.events.delete(key);
            }
        }
        // 3 = Exit
        else if (tileType === 3) {
            this.depth++;
            this.bus.emit('level:complete');
            this.generateLevel();
            this.playerPos = { x: 1, y: 1 };
            this.bus.emit('state:updated');
        }
        
        this.bus.emit('state:updated');
    }

    resolveChoice(action) {
        switch(action) {
            case 'risk_energy':
                if (Math.random() > 0.5) {
                    this.energy += 20;
                    this.bus.emit('msg', 'Energy restored +20');
                } else {
                    this.energy -= 15;
                    this.bus.emit('msg', 'System shock! -15 Energy');
                }
                break;
            case 'shortcut':
                this.energy -= 10;
                // Break a nearby wall
                if(this.playerPos.x < this.mapWidth-2) this.map[this.playerPos.y][this.playerPos.x + 1] = 0;
                break;
            case 'wait':
                this.energy -= 2;
                break;
        }
        if(this.energy > 100) this.energy = 100;
        this.bus.emit('state:updated');
    }
}

// --- 4. RENDER ENGINE (HTML5 Canvas Optimized) ---
class Renderer {
    constructor(canvas, state) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d', { alpha: false }); // Opt: No transparency needed on bg
        this.state = state;
        this.resize();
        
        // Particle System
        this.particles = [];
        
        window.addEventListener('resize', () => this.resize());
    }

    resize() {
        this.canvas.width = window.innerWidth;
        this.canvas.height = window.innerHeight;
        CONSTANTS.VIEWPORT_W = this.canvas.width;
        CONSTANTS.VIEWPORT_H = this.canvas.height;
    }

    addParticle(x, y, color) {
        this.particles.push({
            x, y, 
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2,
            life: 1.0,
            color
        });
    }

    draw() {
        // Clear
        this.ctx.fillStyle = CONSTANTS.COLORS.FLOOR; // Background clear
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Camera Math (Center player)
        const cellSize = Math.min(this.canvas.width, this.canvas.height) / 12; // Responsive zoom
        const offsetX = (this.canvas.width / 2) - (this.state.playerPos.x * cellSize) - (cellSize / 2);
        const offsetY = (this.canvas.height / 2) - (this.state.playerPos.y * cellSize) - (cellSize / 2);

        this.ctx.save();
        this.ctx.translate(offsetX, offsetY);

        // Draw Map
        for (let y = 0; y < this.state.mapHeight; y++) {
            for (let x = 0; x < this.state.mapWidth; x++) {
                const cell = this.state.map[y][x];
                const px = x * cellSize;
                const py = y * cellSize;

                // Draw Grid/Floor
                this.ctx.strokeStyle = '#1a1a1a';
                this.ctx.lineWidth = 1;
                this.ctx.strokeRect(px, py, cellSize, cellSize);

                if (cell === 1) {
                    // Wall
                    this.ctx.fillStyle = CONSTANTS.COLORS.WALL;
                    this.ctx.fillRect(px, py, cellSize, cellSize);
                    // 3D-ish top accent
                    this.ctx.fillStyle = '#333';
                    this.ctx.fillRect(px, py, cellSize, cellSize * 0.1);
                } else if (cell === 2) {
                    // Event
                    this.ctx.fillStyle = CONSTANTS.COLORS.EVENT;
                    this.ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 200) * 0.2; // Pulse
                    this.ctx.beginPath();
                    this.ctx.arc(px + cellSize/2, py + cellSize/2, cellSize * 0.3, 0, Math.PI * 2);
                    this.ctx.fill();
                    this.ctx.globalAlpha = 1.0;
                } else if (cell === 3) {
                    // Goal
                    this.ctx.strokeStyle = CONSTANTS.COLORS.GOAL;
                    this.ctx.lineWidth = 3;
                    this.ctx.strokeRect(px + 10, py + 10, cellSize - 20, cellSize - 20);
                }
            }
        }

        // Draw Player
        const pX = this.state.playerPos.x * cellSize;
        const pY = this.state.playerPos.y * cellSize;
        
        // Trail
        this.ctx.fillStyle = CONSTANTS.COLORS.TRAIL;
        this.ctx.fillRect(pX, pY, cellSize, cellSize);

        // Player Entity
        this.ctx.shadowBlur = 15;
        this.ctx.shadowColor = CONSTANTS.COLORS.PLAYER;
        this.ctx.fillStyle = CONSTANTS.COLORS.PLAYER;
        this.ctx.beginPath();
        this.ctx.arc(pX + cellSize/2, pY + cellSize/2, cellSize * 0.35, 0, Math.PI*2);
        this.ctx.fill();
        this.ctx.shadowBlur = 0;

        this.ctx.restore();

        // UI Overlay for Particles (Screen Space)
        this.updateParticles();
    }

    updateParticles() {
        // Simple particle loop
        for (let i = this.particles.length - 1; i >= 0; i--) {
            let p = this.particles[i];
            p.life -= 0.02;
            p.x += p.vx;
            p.y += p.vy;
            if (p.life <= 0) this.particles.splice(i, 1);
        }
    }
}

// --- 5. APPLICATION CORE (The Glue) ---
class App {
    constructor() {
        this.bus = new EventEmitter();
        this.audio = new AudioEngine();
        this.state = new GameState(this.bus);
        this.canvas = document.getElementById('gameCanvas');
        this.renderer = new Renderer(this.canvas, this.state);
        
        // DOM Elements
        this.ui = {
            energy: document.getElementById('energy-val'),
            depth: document.getElementById('depth-val'),
            modal: document.getElementById('modal-overlay'),
            title: document.getElementById('choice-title'),
            desc: document.getElementById('choice-desc'),
            opts: document.getElementById('choice-options')
        };

        this.bindEvents();
        this.state.init();
        this.loop();
    }

    bindEvents() {
        // Keyboard
        window.addEventListener('keydown', (e) => {
            if (this.state.isInputLocked) return;
            switch(e.key) {
                case 'ArrowUp': case 'w': this.state.movePlayer(0, -1); break;
                case 'ArrowDown': case 's': this.state.movePlayer(0, 1); break;
                case 'ArrowLeft': case 'a': this.state.movePlayer(-1, 0); break;
                case 'ArrowRight': case 'd': this.state.movePlayer(1, 0); break;
            }
        });

        // Touch
        document.querySelectorAll('.d-pad-btn').forEach(btn => {
            btn.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Stop zoom
                const dir = btn.dataset.dir;
                if (dir === 'up') this.state.movePlayer(0, -1);
                if (dir === 'down') this.state.movePlayer(0, 1);
                if (dir === 'left'
                    
