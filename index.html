```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>PROJECT: AETHER VANGUARD (Alpha Build)</title>
    <style>
        /* INDUSTRIAL UI STYLING */
        :root {
            --hud-color: rgba(255, 255, 255, 0.9);
            --accent-gold: #D4AF37; /* Zelda/Elden Ring vibe */
            --accent-red: #ff4d4d;
            --accent-stamina: #00d2ff;
        }
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; user-select: none; -webkit-user-select: none; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* HUD LAYER */
        #ui-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; pointer-events: none; }
        
        .bar-container {
            position: absolute; top: 20px; left: 20px; width: 250px;
            background: rgba(0,0,0,0.5); border-radius: 4px; padding: 5px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,255,255,0.1);
        }
        .stat-bar { height: 8px; border-radius: 2px; margin-bottom: 4px; transition: width 0.1s linear; box-shadow: 0 0 10px currentColor; }
        #hp-bar { background: var(--accent-red); width: 100%; color: var(--accent-red); }
        #stamina-bar { background: var(--accent-stamina); width: 100%; color: var(--accent-stamina); }

        /* VIRTUAL CONTROLS (Mobile) */
        .touch-zone { position: absolute; bottom: 40px; pointer-events: auto; }
        #joystick-zone { left: 40px; width: 120px; height: 120px; border: 2px solid rgba(255,255,255,0.2); border-radius: 50%; }
        #joystick-knob { width: 50px; height: 50px; background: rgba(255,255,255,0.5); border-radius: 50%; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; box-shadow: 0 0 15px rgba(255,255,255,0.3); }
        
        #action-zone { right: 40px; display: flex; gap: 20px; align-items: flex-end; }
        .action-btn {
            width: 70px; height: 70px; border-radius: 50%;
            background: rgba(20, 20, 20, 0.6); border: 2px solid var(--hud-color);
            color: white; display: flex; justify-content: center; align-items: center;
            font-weight: bold; font-size: 14px; backdrop-filter: blur(4px);
            transition: transform 0.1s; cursor: pointer;
        }
        .action-btn:active { transform: scale(0.9); background: var(--accent-gold); color: black; }
        
        #loading {
            position: absolute; top:0; left:0; width:100%; height:100%; background: #050505; z-index: 100;
            display: flex; justify-content: center; align-items: center; color: var(--accent-gold);
            font-size: 24px; letter-spacing: 5px;
        }
        
        /* CINEMATIC LETTERBOXING */
        .letterbox { position: absolute; left: 0; width: 100%; height: 0%; background: black; transition: height 0.5s ease; z-index: 9; }
        .lb-top { top: 0; }
        .lb-bottom { bottom: 0; }

    </style>
</head>
<body>

<!-- CORE STRUCTURE -->
<div id="loading">INITIALIZING NEURONAL LINK...</div>
<div id="canvas-container"></div>

<div id="ui-layer">
    <div class="letterbox lb-top"></div>
    <div class="letterbox lb-bottom"></div>

    <div class="bar-container">
        <div id="hp-bar" class="stat-bar"></div>
        <div id="stamina-bar" class="stat-bar"></div>
    </div>

    <!-- TOUCH CONTROLS (Visible on Mobile/Tablet logic) -->
    <div id="joystick-zone" class="touch-zone">
        <div id="joystick-knob"></div>
    </div>
    <div id="action-zone" class="touch-zone">
        <div class="action-btn" id="btn-dodge" data-key="Space">DODGE</div>
        <div class="action-btn" id="btn-attack" style="width: 90px; height: 90px; border-color: var(--accent-red);" data-key="Click">ATK</div>
    </div>
</div>

<!-- ENGINE IMPORT (Three.js + Utils) -->
<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';
import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
import { ShaderPass } from 'three/addons/postprocessing/ShaderPass.js';
import { GammaCorrectionShader } from 'three/addons/shaders/GammaCorrectionShader.js';

/**
 * NEXUS ARCHITECT ENGINE V4.0
 * PATTERNS: Entity-Component-System (Lite), State Machine, Object Pooling, Shader Instancing
 */

// --- CONFIGURATION ---
const CONFIG = {
    FOV: 45,
    SHADOW_RES: 2048,
    GRASS_COUNT: 45000, // High density for visuals
    WORLD_SIZE: 200,
    CAM_OFFSET: new THREE.Vector3(0, 18, 18), // Isometric 2.5D View
    PHYSICS_DT: 1/60,
    GRAVITY: -30
};

// --- GLOBAL UTILS ---
const MATH = {
    clamp: (v, min, max) => Math.max(min, Math.min(v, max)),
    lerp: (a, b, t) => a + (b - a) * t,
    randFloat: (min, max) => Math.random() * (max - min) + min
};

// --- SHADERS (THE "SECRET SAUCE") ---

const GRASS_VERTEX_SHADER = `
    varying vec2 vUv;
    varying vec3 vColor;
    uniform float time;
    
    // Simplex Noise Function (Simplified)
    vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
    vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
    float snoise(vec2 v) {
        const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
        vec2 i  = floor(v + dot(v, C.yy) );
        vec2 x0 = v -   i + dot(i, C.xx);
        vec2 i1;
        i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
        vec4 x12 = x0.xyxy + C.xxzz;
        x12.xy -= i1;
        i = mod289(i);
        vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));
        vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);
        m = m*m ;
        m = m*m ;
        vec3 x = 2.0 * fract(p * C.www) - 1.0;
        vec3 h = abs(x) - 0.5;
        vec3 ox = floor(x + 0.5);
        vec3 a0 = x - ox;
        m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );
        vec3 g;
        g.x  = a0.x  * x0.x  + h.x  * x0.y;
        g.yz = a0.yz * x12.xz + h.yz * x12.yw;
        return 130.0 * dot(m, g);
    }

    void main() {
        vUv = uv;
        vColor = instanceColor;
        vec3 pos = position;
        
        // GHOST OF TSUSHIMA WIND LOGIC
        // Only move the top of the blade (uv.y > 0.0)
        float noise = snoise(vec2(instanceMatrix[3][0] * 0.05 + time * 0.5, instanceMatrix[3][2] * 0.05 + time * 0.5));
        float windStrength = pow(uv.y, 2.0) * 1.5;
        
        pos.x += noise * windStrength;
        pos.z += noise * 0.5 * windStrength;
        
        // Curve blade slightly
        pos.z -= pow(uv.y, 2.0) * 0.5;

        vec4 mvPosition = modelViewMatrix * instanceMatrix * vec4(pos, 1.0);
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const GRASS_FRAGMENT_SHADER = `
    varying vec2 vUv;
    varying vec3 vColor;
    
    void main() {
        // ZELDA TOTK STYLE GRADIENT
        vec3 colorBottom = vColor * 0.6;
        vec3 colorTop = vColor * 1.4;
        vec3 finalColor = mix(colorBottom, colorTop, vUv.y);
        
        // Fake Ambient Occlusion at root
        if(vUv.y < 0.1) finalColor *= vUv.y * 10.0;
        
        gl_FragColor = vec4(finalColor, 1.0);
    }
`;

const TOON_VERTEX = `
    varying vec3 vNormal;
    varying vec3 vViewDir;
    void main() {
        vNormal = normalize(normalMatrix * normal);
        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
        vViewDir = -mvPosition.xyz;
        gl_Position = projectionMatrix * mvPosition;
    }
`;

const TOON_FRAGMENT = `
    uniform vec3 color;
    uniform vec3 lightDir;
    varying vec3 vNormal;
    varying vec3 vViewDir;

    void main() {
        // CELL SHADING LOGIC
        float intensity = dot(vNormal, normalize(lightDir));
        
        // Banding (Zelda Breath of the Wild style)
        if (intensity > 0.95) intensity = 1.0;
        else if (intensity > 0.5) intensity = 0.7;
        else if (intensity > 0.25) intensity = 0.4;
        else intensity = 0.2;
        
        // Rim Light (Ethereal look)
        vec3 viewDir = normalize(vViewDir);
        float rim = 1.0 - dot(vNormal, viewDir);
        rim = smoothstep(0.6, 1.0, rim);
        
        vec3 finalColor = color * intensity + vec3(rim) * 0.3;
        gl_FragColor = vec4(finalColor, 1.0);
    }
`;

// --- SYSTEMS ---

class InputSystem {
    constructor() {
        this.keys = {};
        this.joystick = { x: 0, y: 0, active: false };
        this.actions = { dodge: false, attack: false };
        
        // Desktop
        window.addEventListener('keydown', (e) => this.keys[e.code] = true);
        window.addEventListener('keyup', (e) => this.keys[e.code] = false);

        // Mobile / Touch
        this.setupTouch();
    }

    setupTouch() {
        const joyZone = document.getElementById('joystick-zone');
        const joyKnob = document.getElementById('joystick-knob');
        let startX, startY;
        const maxDist = 35;

        joyZone.addEventListener('touchstart', (e) => {
            e.preventDefault();
            this.joystick.active = true;
            startX = e.touches[0].clientX;
            startY = e.touches[0].clientY;
        }, {passive: false});

        joyZone.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!this.joystick.active) return;
            
            const dx = e.touches[0].clientX - startX;
            const dy = e.touches[0].clientY - startY;
            const dist = Math.min(Math.sqrt(dx*dx + dy*dy), maxDist);
            const angle = Math.atan2(dy, dx);
            
            const moveX = Math.cos(angle) * dist;
            const moveY = Math.sin(angle) * dist;
            
            joyKnob.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
            
            this.joystick.x = moveX / maxDist;
            this.joystick.y = moveY / maxDist;
        }, {passive: false});

        const resetJoy = () => {
            this.joystick.active = false;
            this.joystick.x = 0;
            this.joystick.y = 0;
            joyKnob.style.transform = `translate(-50%, -50%)`;
        };
        joyZone.addEventListener('touchend', resetJoy);

        // Buttons
        const bindBtn = (id, action) => {
            const btn = document.getElementById(id);
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); this.actions[action] = true; });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); this.actions[action] = false; });
            btn.addEventListener('mousedown', () => this.actions[action] = true);
            btn.addEventListener('mouseup', () => this.actions[action] = false);
        };
        bindBtn('btn-dodge', 'dodge');
        bindBtn('btn-attack', 'attack');
    }

    getMovementVector() {
        let x = 0, z = 0;
        
        // Keyboard
        if (this.keys['KeyW'] || this.keys['ArrowUp']) z -= 1;
        if (this.keys['KeyS'] || this.keys['ArrowDown']) z += 1;
        if (this.keys['KeyA'] || this.keys['ArrowLeft']) x -= 1;
        if (this.keys['KeyD'] || this.keys['ArrowRight']) x += 1;
        
        // Merge with Joystick
        if (this.joystick.active) {
            x = this.joystick.x;
            z = this.joystick.y;
        }

        // Actions
        if (this.keys['Space']) this.actions.dodge = true;
        else if (!this.joystick.active) this.actions.dodge = false; // Reset if keyboard not pressed

        const vec = new THREE.Vector3(x, 0, z);
        if (vec.length() > 1) vec.normalize();
        return vec;
    }
}

class ParticleSystem {
    constructor(scene) {
        this.particles = [];
        this.scene = scene;
        
        const geo = new THREE.PlaneGeometry(0.3, 0.3);
        const mat = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, transparent: true, opacity: 0.8, side: THREE.DoubleSide 
        });

        // Object Pool
        for(let i=0; i<50; i++) {
            const mesh = new THREE.Mesh(geo, mat);
            mesh.visible = false;
            this.scene.add(mesh);
            this.particles.push({ mesh, life: 0, velocity: new THREE.Vector3() });
        }
    }

    emit(pos, color, count) {
        let emitted = 0;
        for(let p of this.particles) {
            if(p.life <= 0 && emitted < count) {
                p.mesh.visible = true;
                p.mesh.position.copy(pos);
                p.mesh.material.color.setHex(color);
                p.mesh.rotation.z = Math.random() * Math.PI;
                p.life = 1.0;
                p.velocity.set(
                    (Math.random() - 0.5) * 5, 
                    Math.random() * 5, 
                    (Math.random() - 0.5) * 5
                );
                emitted++;
            }
        }
    }

    update(dt) {
        for(let p of this.particles) {
            if(p.life > 0) {
                p.life -= dt * 2.0;
                p.mesh.position.addScaledVector(p.velocity, dt);
                p.velocity.y -= 9.8 * dt; // Gravity
                p.mesh.scale.setScalar(p.life);
                p.mesh.rotation.z += dt * 5;
                if(p.life <= 0) p.mesh.visible = false;
            }
        }
    }
}

class GameWorld {
    constructor(scene, renderer) {
        this.scene = scene;
        this.renderer = renderer;
        this.setupLighting();
        this.setupTerrain();
        this.setupFoliage();
    }

    setupLighting() {
        const ambient = new THREE.AmbientLight(0x404040, 1.5); // Soft blue ambient
        this.scene.add(ambient);

        // Sun (RDR2 Lighting style)
        this.sun = new THREE.DirectionalLight(0xffdfba, 3.0);
        this.sun.position.set(50, 80, 50);
        this.sun.castShadow = true;
        this.sun.shadow.mapSize.width = CONFIG.SHADOW_RES;
        this.sun.shadow.mapSize.height = CONFIG.SHADOW_RES;
        this.sun.shadow.camera.near = 0.5;
        this.sun.shadow.camera.far = 200;
        this.sun.shadow.camera.left = -50;
        this.sun.shadow.camera.right = 50;
        this.sun.shadow.camera.top = 50;
        this.sun.shadow.camera.bottom = -50;
        this.scene.add(this.sun);
        
        // Volumetric Fog Feel
        this.scene.fog = new THREE.FogExp2(0x87CEEB, 0.015);
        this.scene.background = new THREE.Color(0x87CEEB);
    }

    setupTerrain() {
        const geo = new THREE.PlaneGeometry(CONFIG.WORLD_SIZE, CONFIG.WORLD_SIZE, 64, 64);
        geo.rotateX(-Math.PI / 2);
        
        // Displace vertices for uneven terrain
        const pos = geo.attributes.position;
        for(let i=0; i<pos.count; i++) {
            const x = pos.getX(i);
            const z = pos.getZ(i);
            // Simple hill logic
            const y = Math.sin(x * 0.05) * 2 + Math.cos(z * 0.05) * 2;
            pos.setY(i, y);
        }
        geo.computeVertexNormals();

        const mat = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0x3a5f0b) }, // Dark green ground
                lightDir: { value: new THREE.Vector3(0.5, 0.8, 0.5) }
            },
            vertexShader: TOON_VERTEX,
            fragmentShader: TOON_FRAGMENT
        });
        
        const ground = new THREE.Mesh(geo, mat);
        ground.receiveShadow = true;
        this.scene.add(ground);
        this.groundMesh = ground;
    }

    setupFoliage() {
        // Instanced Grass (BotW Style)
        const bladeGeo = new THREE.PlaneGeometry(0.5, 2.5); // Tall grass
        bladeGeo.translate(0, 1.25, 0); // Pivot at bottom

        this.grassMat = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 }
            },
            vertexShader: GRASS_VERTEX_SHADER,
            fragmentShader: GRASS_FRAGMENT_SHADER,
            side: THREE.DoubleSide
        });

        this.grassMesh = new THREE.InstancedMesh(bladeGeo, this.grassMat, CONFIG.GRASS_COUNT);
        
        const dummy = new THREE.Object3D();
        const colors = [];
        
        for(let i=0; i<CONFIG.GRASS_COUNT; i++) {
            // Distribute in a circle around center, avoiding immediate center
            const angle = Math.random() * Math.PI * 2;
            const radius = 5 + Math.random() * 80; // Leave center clear
            
            dummy.position.set(
                Math.cos(angle) * radius,
                0,
                Math.sin(angle) * radius
            );
            
            // Adjust height to terrain
            // Raycasting is expensive, using math approximation from terrain gen
            const y = Math.sin(dummy.position.x * 0.05) * 2 + Math.cos(dummy.position.z * 0.05) * 2;
            dummy.position.y = y;

            dummy.rotation.y = Math.random() * Math.PI;
            dummy.scale.setScalar(0.8 + Math.random() * 0.5);
            dummy.updateMatrix();
            this.grassMesh.setMatrixAt(i, dummy.matrix);

            // Color variation (Tsushima gold/green/red mix)
            const colorVar = Math.random();
            const color = new THREE.Color();
            if(colorVar > 0.9) color.setHex(0xff4d4d); // Red flower
            else if(colorVar > 0.7) color.setHex(0xD4AF37); // Gold grass
            else color.setHex(0x55aa55); // Green
            
            this.grassMesh.setColorAt(i, color);
        }
        
        this.grassMesh.instanceMatrix.needsUpdate = true;
        this.grassMesh.instanceColor.needsUpdate = true;
        this.grassMesh.receiveShadow = true;
        this.scene.add(this.grassMesh);
    }

    update(time) {
        this.grassMat.uniforms.time.value = time;
    }
}

class Player {
    constructor(scene, input, particleSystem) {
        this.scene = scene;
        this.input = input;
        this.particles = particleSystem;
        
        // Stats (RPG Elements)
        this.stats = {
            hp: 100,
            maxHp: 100,
            stamina: 100,
            maxStamina: 100
        };

        // State Machine
        this.state = 'IDLE'; // IDLE, RUN, DODGE, ATTACK
        this.velocity = new THREE.Vector3();
        this.speed = 12;
        this.dodgeSpeed = 35;
        this.stateTimer = 0;

        // Visuals
        const geo = new THREE.CapsuleGeometry(0.8, 1.8, 4, 8);
        const mat = new THREE.ShaderMaterial({
            uniforms: {
                color: { value: new THREE.Color(0x22aaff) }, // Hero Blue
                lightDir: { value: new THREE.Vector3(0.5, 0.8, 0.5) }
            },
            vertexShader: TOON_VERTEX,
            fragmentShader: TOON_FRAGMENT
        });
        
        this.mesh = new THREE.Mesh(geo, mat);
        this.mesh.position.y = 2;
        this.mesh.castShadow = true;
        
        // Direction Indicator (Cape-like)
        const capeGeo = new THREE.BoxGeometry(1, 1.5, 0.2);
        capeGeo.translate(0, 0, -0.6);
        const capeMesh = new THREE.Mesh(capeGeo, new THREE.MeshStandardMaterial({color: 0xffffff}));
        this.mesh.add(capeMesh);
        
        this.scene.add(this.mesh);
        
        // Sword
        const swordGeo = new THREE.BoxGeometry(0.2, 2.5, 0.2);
        const swordMat = new THREE.MeshStandardMaterial({color: 0xcccccc, emissive: 0x222222});
        this.sword = new THREE.Mesh(swordGeo, swordMat);
        this.sword.position.set(0.8, 0.5, 0.5);
        this.sword.rotation.x = Math.PI / 2;
        this.mesh.add(this.sword);
        
