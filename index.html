```html
<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>NEON HORIZON: INFINITY LOOP</title>
    <style>
        :root {
            --primary: #00f3ff;
            --danger: #ff0055;
            --gold: #ffd700;
            --bg: #050505;
            --ui-font: 'Segoe UI', 'Roboto', monospace;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            background-color: var(--bg);
            overflow: hidden;
            font-family: var(--ui-font);
            user-select: none;
            -webkit-user-select: none;
        }

        #gameCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        /* HUD LAYER */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 10px rgba(0, 243, 255, 0.5);
        }

        .stat-box {
            background: rgba(0, 0, 0, 0.6);
            border-left: 4px solid var(--primary);
            padding: 10px 20px;
            backdrop-filter: blur(4px);
            color: #fff;
            transform: skewX(-10deg);
        }

        .stat-label { font-size: 0.8rem; color: #aaa; }
        .stat-value { font-size: 1.5rem; font-weight: 800; color: var(--primary); }
        .danger-text { color: var(--danger); border-color: var(--danger); }

        /* MENU OVERLAY */
        #menu-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(5, 5, 5, 0.85);
            z-index: 20;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            pointer-events: auto;
            backdrop-filter: blur(10px);
            transition: opacity 0.3s;
        }

        h1 {
            color: #fff;
            font-size: 4rem;
            margin: 0;
            text-transform: uppercase;
            letter-spacing: 10px;
            background: linear-gradient(90deg, var(--primary), #fff, var(--primary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glitch 2s infinite;
        }

        .btn {
            margin-top: 40px;
            padding: 15px 50px;
            background: transparent;
            border: 2px solid var(--primary);
            color: var(--primary);
            font-size: 1.2rem;
            text-transform: uppercase;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }

        .btn:hover {
            background: var(--primary);
            color: #000;
            box-shadow: 0 0 30px var(--primary);
        }

        .hidden { opacity: 0; pointer-events: none; }

        @keyframes glitch {
            0% { text-shadow: 2px 2px var(--danger), -2px -2px var(--primary); }
            50% { text-shadow: -2px -2px var(--danger), 2px 2px var(--primary); }
            100% { text-shadow: 2px 2px var(--danger), -2px -2px var(--primary); }
        }
    </style>
</head>
<body>

    <!-- RENDERING ENGINE -->
    <canvas id="gameCanvas"></canvas>

    <!-- UI INTERFACE -->
    <div id="ui-layer">
        <div class="hud-top">
            <div class="stat-box">
                <div class="stat-label">NIVEAU</div>
                <div class="stat-value" id="hud-level">1</div>
            </div>
            <div class="stat-box" style="border-color: var(--gold)">
                <div class="stat-label">SCORE</div>
                <div class="stat-value" id="hud-score">0</div>
            </div>
            <div class="stat-box danger-text">
                <div class="stat-label">INTÉGRITÉ</div>
                <div class="stat-value" id="hud-health">100%</div>
            </div>
        </div>
    </div>

    <!-- MENUS -->
    <div id="menu-overlay">
        <h1 id="menu-title">NEON HORIZON</h1>
        <p style="color: #aaa; margin-top: 10px; font-size: 1.2rem;" id="menu-subtitle">ÉVITER. SURVIVRE. ÉVOLUER.</p>
        <button class="btn" id="start-btn" onclick="GameManager.start()">INITIALISER SYSTÈME</button>
        <p style="color: #555; margin-top: 30px; font-size: 0.8rem;">DONNÉES SAUVEGARDÉES AUTOMATIQUEMENT</p>
    </div>

    <script>
    /**
     * TRIPLE-A SYNTHESIS ENGINE v4.0
     * Core Logic: Object Pooling, Vectors, State Machine
     */

    // --- MATH & UTILS MODULE ---
    const MathLib = {
        lerp: (a, b, t) => a + (b - a) * t,
        clamp: (val, min, max) => Math.min(Math.max(val, min), max),
        randRange: (min, max) => Math.random() * (max - min) + min,
        distSq: (x1, y1, x2, y2) => (x2 - x1) ** 2 + (y2 - y1) ** 2,
        
        // Système de vecteurs optimisé (mutations directes pour éviter le GC)
        Vec2: class {
            constructor(x = 0, y = 0) { this.x = x; this.y = y; }
            set(x, y) { this.x = x; this.y = y; return this; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(s) { this.x *= s; this.y *= s; return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() {
                let m = this.mag();
                if (m > 0) this.mult(1 / m);
                return this;
            }
        }
    };

    // --- PERSISTENCE MODULE (SAVE SYSTEM) ---
    const SaveManager = {
        KEY: 'NEON_HORIZON_SAVE_V1',
        data: {
            level: 1,
            highScore: 0,
            xp: 0
        },
        save() {
            try {
                localStorage.setItem(this.KEY, JSON.stringify(this.data));
            } catch (e) { console.warn("Storage unavailable"); }
        },
        load() {
            const saved = localStorage.getItem(this.KEY);
            if (saved) {
                const parsed = JSON.parse(saved);
                this.data = { ...this.data, ...parsed };
                // On reset le niveau courant pour le challenge, mais on garde le highscore
                // Pour cet exercice, on va reprendre au niveau sauvegardé (Progression)
            }
            return this.data;
        },
        resetProgress() {
            this.data.level = 1;
            this.data.xp = 0;
            this.save();
        }
    };

    // --- POOLING SYSTEM (MEMORY MANAGEMENT) ---
    class ObjectPool {
        constructor(createFn, initialSize = 50) {
            this.createFn = createFn;
            this.pool = [];
            this.active = [];
            for (let i = 0; i < initialSize; i++) this.pool.push(this.createFn());
        }

        get() {
            let obj = this.pool.length > 0 ? this.pool.pop() : this.createFn();
            this.active.push(obj);
            obj.active = true;
            if (obj.onSpawn) obj.onSpawn();
            return obj;
        }

        release(obj) {
            const index = this.active.indexOf(obj);
            if (index > -1) {
                this.active.splice(index, 1);
                obj.active = false;
                this.pool.push(obj);
            }
        }

        updateAll(dt, context) {
            // Boucle inverse pour suppression sûre
            for (let i = this.active.length - 1; i >= 0; i--) {
                const obj = this.active[i];
                obj.update(dt);
                if (!obj.active) { // Auto-release logic inside update
                    this.release(obj);
                } else {
                    obj.draw(context);
                }
            }
        }
        
        clear() {
            while(this.active.length > 0) {
                this.release(this.active[0]);
            }
        }
    }

    // --- GAME ENTITIES ---

    // SYSTEME DE PARTICULES (VISUAL FX)
    class Particle {
        constructor() {
            this.pos = new MathLib.Vec2();
            this.vel = new MathLib.Vec2();
            this.life = 0;
            this.maxLife = 0;
            this.color = '#fff';
            this.size = 2;
            this.active = false;
        }
        onSpawn() {}
        update(dt) {
            this.life -= dt;
            this.pos.add(new MathLib.Vec2(this.vel.x, this.vel.y).mult(dt));
            this.size *= 0.95; // Shrink
            if (this.life <= 0 || this.size < 0.1) this.active = false;
        }
        draw(ctx) {
            ctx.globalAlpha = this.life / this.maxLife;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
        }
    }

    // JOUEUR (THE CORE)
    const Player = {
        pos: new MathLib.Vec2(),
        targetPos: new MathLib.Vec2(),
        velocity: new MathLib.Vec2(),
        radius: 15,
        health: 100,
        color: '#00f3ff',
        trailTimer: 0,
        
        init() {
            this.pos.set(window.innerWidth/2, window.innerHeight/2);
            this.targetPos.set(this.pos.x, this.pos.y);
            this.health = 100;
        },

        update(dt) {
            // Mouvement fluide (Lerp avec inertie)
            const speed = 8.0; // Réactivité
            this.pos.x = MathLib.lerp(this.pos.x, this.targetPos.x, dt * speed);
            this.pos.y = MathLib.lerp(this.pos.y, this.targetPos.y, dt * speed);

            // Contraintes écran
            this.pos.x = MathLib.clamp(this.pos.x, this.radius, window.innerWidth - this.radius);
            this.pos.y = MathLib.clamp(this.pos.y, this.radius, window.innerHeight - this.radius);

            // Génération de traînée (Visual Juice)
            this.trailTimer += dt;
            if (this.trailTimer > 0.05) {
                this.trailTimer = 0;
                GameManager.spawnParticle(this.pos.x, this.pos.y, '#00f3ff', 0);
            }
        },

        draw(ctx) {
            // Glow Effect
            ctx.shadowBlur = 20;
            ctx.shadowColor = this.color;
            
            // Core
            ctx.strokeStyle = this.color;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            ctx.stroke();

            // Inner Core (Health indicator)
            ctx.fillStyle = `rgba(0, 243, 255, ${this.health / 100})`;
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius * 0.6, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.shadowBlur = 0; // Reset pour perf
        },
        
        hit(damage) {
            this.health -= damage;
            GameManager.shake(5); // Screen shake
            GameManager.spawnExplosion(this.pos.x, this.pos.y, 10, '#ff0055');
            if (this.health <= 0) GameManager.gameOver();
            UI.updateHealth(this.health);
        }
    };

    // ENNEMIS (Procedural Attributes)
    class Enemy {
        constructor() {
            this.pos = new MathLib.Vec2();
            this.vel = new MathLib.Vec2();
            this.active = false;
            this.type = 0; // 0: Follower, 1: Dasher
            this.speed = 0;
            this.radius = 10;
        }

        onSpawn() {
            // Spawn hors écran aléatoire
            const angle = Math.random() * Math.PI * 2;
            const dist = Math.max(window.innerWidth, window.innerHeight) * 0.7;
            this.pos.x = (window.innerWidth/2) + Math.cos(angle) * dist;
            this.pos.y = (window.innerHeight/2) + Math.sin(angle) * dist;
            
            // Difficulté progressive basée sur le niveau
            const levelMult = 1 + (GameManager.level * 0.15);
            
            this.type = Math.random() > 0.8 ? 1 : 0;
            this.speed = (MathLib.randRange(100, 200) * levelMult);
            this.radius = this.type === 1 ? 8 : 12;
            this.color = this.type === 1 ? '#ffcc00' : '#ff0055';
        }

        update(dt) {
            // Logique de poursuite
            let dir = new MathLib.Vec2(Player.pos.x - this.pos.x, Player.pos.y - this.pos.y).normalize();
            
            if (this.type === 1) { 
                // Dasher: mouvement saccadé
                this.speed += Math.sin(Date.now() / 100) * 5;
            }

            this.pos.add(dir.mult(this.speed * dt));

            // Collision Joueur
            const dist = MathLib.distSq(this.pos.x, this.pos.y, Player.pos.x, Player.pos.y);
            const rSum = this.radius + Player.radius;
            if (dist < rSum * rSum) {
                Player.hit(20);
                this.active = false; // Suicide
            }

            // Hors limites (nettoyage si trop loin)
            if (Math.abs(this.pos.x - window.innerWidth/2) > window.innerWidth) this.active = false;
        }

        draw(ctx) {
            ctx.shadowBlur = 10;
            ctx.shadowColor = this.color;
            ctx.fillStyle = this.color;
            
            ctx.beginPath();
            if (this.type === 0) {
                ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            } else {
                // Triangle pour les dashers
                ctx.moveTo(this.pos.x + this.radius, this.pos.y);
                ctx.lineTo(this.pos.x - this.radius, this.pos.y - this.radius);
                ctx.lineTo(this.pos.x - this.radius, this.pos.y + this.radius);
            }
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    // --- MAIN GAME MANAGER (SINGLETON) ---
    const GameManager = {
        canvas: document.getElementById('gameCanvas'),
        ctx: document.getElementById('gameCanvas').getContext('2d', { alpha: false }), // Alpha false pour perf
        
        state: 'MENU', // MENU, PLAYING, GAMEOVER
        lastTime: 0,
        accumulator: 0,
        
        level: 1,
        score: 0,
        scoreBuffer: 0, // Pour le level up
        
        enemyPool: null,
        particlePool: null,
        
        spawnTimer: 0,
        shakeTime: 0,

        init() {
            this.resize();
            window.addEventListener('resize', () => this.resize());
            
            // Input Handling
            window.addEventListener('mousemove', e => {
                Player.targetPos.set(e.clientX, e.clientY);
            });
            window.addEventListener('touchmove', e => {
                e.preventDefault();
                Player.targetPos.set(e.touches[0].clientX, e.touches[0].clientY);
            }, { passive: false });

            // Init Pools
            this.enemyPool = new ObjectPool(() => new Enemy(), 100);
            this.particlePool = new ObjectPool(() => new Particle(), 200);

            // Load Data
            const saved = SaveManager.load();
            this.highScore = saved.highScore || 0;
            
            // Start Loop
            requestAnimationFrame(t => this.loop(t));
        },

        start() {
            const saved = SaveManager.load();
            
            // Si on recommence après un game over, on reset le level
            if(this.state === 'GAMEOVER') {
                 SaveManager.resetProgress();
                 this.level = 1;
            } else {
                 this.level = saved.level || 1;
            }

            this.score = 0;
            this.scoreBuffer = 0;
            Player.init();
            
            this.enemyPool.clear();
            this.particlePool.clear();
            
            this.state = 'PLAYING';
            UI.hideMenu();
            UI.updateHUD();
        },

        resize() {
            this.canvas.width = window.innerWidth;
            this.canvas.height = window.innerHeight;
        },

        loop(timestamp) {
            const dt = (timestamp - this.lastTime) / 1000;
            this.lastTime = timestamp;

            if (this.state === 'PLAYING') {
                this.update(Math.min(dt, 0.1)); // Cap dt pour éviter les sauts
                this.draw();
            } else {
                // Dessiner un fond animé même dans le menu
                this.drawBackground();
            }

            requestAnimationFrame(t => this.loop(t));
        },

        update(dt) {
            // Difficulty Manager
            // Plus le niveau est haut, plus ça spawn vite
            const spawnRate = Math.max(0.1, 1.0 - (this.level * 0.08));
            
            this.spawnTimer += dt;
            if (this.spawnTimer > spawnRate) {
                this.spawnTimer = 0;
                this.enemyPool.get();
            }

            // Score passivement incrémenté + Level System
            this.score += dt * 100;
            this.scoreBuffer += dt * 100;
            
            // Courbe de difficulté exponentielle
            const xpNeed = 1000 * Math.pow(1.2, this.level);
            
            if (this.scoreBuffer >= xpNeed) {
                this.levelUp();
            }

            Player.update(dt);
            this.enemyPool.updateAll(dt, this.ctx);
            this.particlePool.updateAll(dt, this.ctx);
            
            if (this.shakeTime > 0) this.shakeTime -= dt;

            UI.updateScore(Math.floor(this.score));
        },

        draw() {
            // Screen Shake Transform
            this.ctx.save();
            if (this.shakeTime > 0) {
                const mag = 5 * (this.shakeTime);
                const dx = (Math.random() - 0.5) * mag;
                const dy = (Math.random() - 0.5) * mag;
                this.ctx.translate(dx, dy);
            }

            this.drawBackground();
            
            // Grid Effect (Cyberpunk aesthetic)
            this.drawGrid();

            Player.draw(this.ctx);
            // Enemies & Particles sont dessinés dans leur updateAll pour optimisation
            
            this.ctx.restore();
        },

        drawBackground() {
            // Clear avec un léger fade pour effet de traînée globale
            this.ctx.fillStyle = 'rgba(5, 5, 5, 0.3)';
            this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        },

        drawGrid() {
            this.ctx.strokeStyle = 'rgba(0, 243, 255, 0.05)';
            this.ctx.lineWidth = 1;
            const gridSize = 50;
            
            // Effet de mouvement de la grille
            const offset = (Date.now() / 50) % gridSize;

            this.ctx.beginPath();
            for (let x = offset; x < this.canvas.width; x += gridSize) {
                this.ctx.moveTo(x, 0);
                this.ctx.lineTo(x, this.canvas.height);
            }
         
