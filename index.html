```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AETHER: PROTOCOL ZERO | NEXUS ARCHITECT</title>
    <style>
        :root {
            --neon-blue: #00f3ff;
            --neon-pink: #ff0055;
            --dark-bg: #050505;
            --ui-font: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        body {
            margin: 0;
            overflow: hidden;
            background-color: var(--dark-bg);
            font-family: var(--ui-font);
            user-select: none;
            -webkit-font-smoothing: antialiased;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 2rem;
            box-sizing: border-box;
        }

        .hud-element {
            color: white;
            text-shadow: 0 0 10px var(--neon-blue);
            opacity: 0.9;
        }

        #score-display {
            font-size: 3rem;
            font-weight: 800;
            letter-spacing: -2px;
        }

        #score-label {
            font-size: 0.8rem;
            text-transform: uppercase;
            letter-spacing: 2px;
            color: var(--neon-blue);
        }

        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            backdrop-filter: blur(10px);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 20;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        }

        #game-over-screen.active {
            opacity: 1;
            pointer-events: all;
        }

        h1 {
            font-size: 4rem;
            color: transparent;
            -webkit-text-stroke: 2px white;
            margin: 0 0 1rem 0;
            text-transform: uppercase;
        }

        button.cyber-btn {
            background: transparent;
            border: 2px solid var(--neon-blue);
            color: var(--neon-blue);
            padding: 1rem 3rem;
            font-size: 1.2rem;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }

        button.cyber-btn:hover {
            background: var(--neon-blue);
            color: var(--dark-bg);
            box-shadow: 0 0 30px var(--neon-blue);
        }

        .scanline {
            width: 100%;
            height: 100px;
            z-index: 10;
            background: linear-gradient(0deg, rgba(0,0,0,0) 0%, rgba(255, 255, 255, 0.05) 50%, rgba(0,0,0,0) 100%);
            opacity: 0.1;
            position: absolute;
            bottom: 100%;
            animation: scanline 10s linear infinite;
            pointer-events: none;
        }

        @keyframes scanline {
            0% { bottom: 100%; }
            100% { bottom: -100px; }
        }

        #instructions {
            position: absolute;
            bottom: 10%;
            width: 100%;
            text-align: center;
            color: rgba(255,255,255,0.5);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>

    <div id="canvas-container"></div>
    <div class="scanline"></div>

    <div id="ui-layer">
        <div class="hud-element">
            <div id="score-label">Data Sync</div>
            <div id="score-display">0</div>
        </div>
        <div id="instructions">Click Left/Right or A/D to Strafe</div>
    </div>

    <div id="game-over-screen">
        <h1>System Failure</h1>
        <button class="cyber-btn" onclick="GameCore.restart()">Reboot Sequence</button>
    </div>

    <!-- Triple-A Architecture: ES Modules for Three.js -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';

        /**
         * NEXUS ARCHITECT v4.0 - INDUSTRIAL GRADE ENGINE
         * Pattern: Entity-Component-System (Hybrid) + Object Pooling + FSM
         */

        // --- CONFIGURATION ---
        const CONFIG = {
            laneWidth: 3.5,
            baseSpeed: 0.8,
            maxSpeed: 2.5,
            acceleration: 0.0001,
            fov: 75,
            bloomThreshold: 0,
            bloomStrength: 1.5,
            bloomRadius: 0.5,
            poolSize: 20
        };

        // --- MATH UTILS ---
        const MathUtils = {
            lerp: (start, end, t) => start * (1 - t) + end * t,
            clamp: (num, min, max) => Math.min(Math.max(num, min), max),
            randRange: (min, max) => Math.random() * (max - min) + min
        };

        // --- OBJECT POOLING SYSTEM (Memory Optimization) ---
        class ObjectPool {
            constructor(createFn, size) {
                this.pool = [];
                this.createFn = createFn;
                for (let i = 0; i < size; i++) {
                    const obj = this.createFn();
                    obj.visible = false;
                    this.pool.push(obj);
                }
            }

            get() {
                const obj = this.pool.find(o => !o.visible);
                if (obj) {
                    obj.visible = true;
                    return obj;
                }
                // Expansion fallback
                const newObj = this.createFn();
                this.pool.push(newObj);
                return newObj;
            }

            release(obj) {
                obj.visible = false;
            }
        }

        // --- ENTITY SYSTEM ---
        class Player {
            constructor(scene) {
                this.lane = 0; // -1, 0, 1
                this.targetX = 0;
                
                // Geometry
                const geometry = new THREE.ConeGeometry(0.5, 1.5, 4);
                geometry.rotateX(Math.PI / 2);
                const material = new THREE.MeshStandardMaterial({ 
                    color: 0x00f3ff, 
                    emissive: 0x0044aa,
                    emissiveIntensity: 0.5,
                    roughness: 0.2,
                    metalness: 0.8,
                    flatShading: true
                });
                
                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.y = 0.5;
                this.mesh.castShadow = true;
                
                // Engine Particles
                this.engineGlow = new THREE.PointLight(0x00f3ff, 2, 5);
                this.engineGlow.position.set(0, 0.5, 1);
                this.mesh.add(this.engineGlow);

                scene.add(this.mesh);
            }

            move(direction) {
                this.lane = MathUtils.clamp(this.lane + direction, -1, 1);
                this.targetX = this.lane * CONFIG.laneWidth;
            }

            update(dt, time) {
                // Smooth Lerp movement
                this.mesh.position.x = MathUtils.lerp(this.mesh.position.x, this.targetX, 10 * dt);
                
                // Dynamic Roll
                const roll = (this.mesh.position.x - this.targetX) * 0.5;
                this.mesh.rotation.z = -roll;
                this.mesh.rotation.x = (Math.sin(time * 10) * 0.05); // Idle hover
            }

            reset() {
                this.lane = 0;
                this.targetX = 0;
                this.mesh.position.set(0, 0.5, 0);
            }
        }

        class ObstacleManager {
            constructor(scene) {
                this.scene = scene;
                this.activeObstacles = [];
                
                // Prefabricated Geometry for Pool
                const geometry = new THREE.BoxGeometry(2, 2, 2);
                const material = new THREE.MeshStandardMaterial({
                    color: 0xff0055,
                    emissive: 0x550011,
                    emissiveIntensity: 0.8,
                    roughness: 0.1,
                    metalness: 0.9,
                    wireframe: false
                });

                this.pool = new ObjectPool(() => {
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = true;
                    this.scene.add(mesh);
                    return mesh;
                }, CONFIG.poolSize);

                this.spawnTimer = 0;
                this.spawnInterval = 1.5; // Seconds
            }

            spawn(speed) {
                const obstacle = this.pool.get();
                // Random Lane
                const lane = Math.floor(MathUtils.randRange(-1, 2)); 
                
                obstacle.position.set(lane * CONFIG.laneWidth, 1, -60); // Spawn far away
                obstacle.scale.setScalar(0.1); // Scale animation start
                
                // Custom data attached to mesh
                obstacle.userData = { 
                    lane: lane, 
                    active: true,
                    rotationSpeed: { x: Math.random(), y: Math.random() } 
                };
            }

            update(dt, speed, playerMesh) {
                // Adjust spawn rate based on speed
                this.spawnInterval = Math.max(0.4, 1.5 - (speed * 0.5));
                this.spawnTimer += dt;

                if (this.spawnTimer > this.spawnInterval) {
                    this.spawn(speed);
                    this.spawnTimer = 0;
                }

                // Update active obstacles
                const killList = [];

                this.pool.pool.forEach(obs => {
                    if (!obs.visible) return;

                    // Move towards player
                    obs.position.z += speed * 40 * dt;
                    
                    // Rotate
                    obs.rotation.x += obs.userData.rotationSpeed.x * dt * 2;
                    obs.rotation.y += obs.userData.rotationSpeed.y * dt * 2;

                    // Spawn animation
                    if(obs.scale.x < 1) obs.scale.addScalar(dt * 5);

                    // Collision Detection (AABB approximation)
                    const distZ = Math.abs(obs.position.z - playerMesh.position.z);
                    const distX = Math.abs(obs.position.x - playerMesh.position.x);

                    if (distZ < 1.5 && distX < 1.0) {
                        window.GameCore.gameOver();
                    }

                    // Recycle
                    if (obs.position.z > 10) {
                        this.pool.release(obs);
                    }
                });
            }

            reset() {
                this.pool.pool.forEach(o => this.pool.release(o));
                this.spawnTimer = 0;
            }
        }

        class Environment {
            constructor(scene) {
                // Moving Grid Floor
                const gridHelper = new THREE.GridHelper(200, 50, 0x00f3ff, 0x111111);
                scene.add(gridHelper);
                this.grid = gridHelper;

                // Fog for depth hiding
                scene.fog = new THREE.FogExp2(CONFIG.baseSpeed, 0.02);
            }

            update(speed, dt) {
                // Infinite grid illusion
                this.grid.position.z += speed * 40 * dt;
                if (this.grid.position.z > 4) {
                    this.grid.position.z = 0;
                }
            }
        }

        // --- MAIN ENGINE ---
        class Engine {
            constructor() {
                this.state = 'MENU'; // MENU, PLAYING, GAMEOVER
                this.score = 0;
                this.speed = CONFIG.baseSpeed;
                this.clock = new THREE.Clock();

                // DOM
                this.container = document.getElementById('canvas-container');
                this.scoreEl = document.getElementById('score-display');
                this.gameOverScreen = document.getElementById('game-over-screen');

                // Three.js Setup
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(CONFIG.fov, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 3, 5);
                this.camera.lookAt(0, 0, -10);

                this.renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.container.appendChild(this.renderer.domElement);

                // Lighting
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.1);
                this.scene.add(ambientLight);
                
                const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
                dirLight.position.set(0, 10, 0);
                this.scene.add(dirLight);

                // Post Processing (Triple-A Glow)
                this.composer = new EffectComposer(this.renderer);
                this.composer.addPass(new RenderPass(this.scene, this.camera));
                
                const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloomPass.threshold = CONFIG.bloomThreshold;
                bloomPass.strength = CONFIG.bloomStrength;
                bloomPass.radius = CONFIG.bloomRadius;
                this.composer.addPass(bloomPass);

                // Systems
                this.player = new Player(this.scene);
                this.obstacles = new ObstacleManager(this.scene);
                this.env = new Environment(this.scene);

                // Input
                this.bindEvents();

                // Start Loop
                this.animate = this.animate.bind(this);
                requestAnimationFrame(this.animate);

                this.startGame();
            }

            bindEvents() {
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.composer.setSize(window.innerWidth, window.innerHeight);
                });

                document.addEventListener('keydown', (e) => {
                    if (this.state !== 'PLAYING') return;
                    if (e.key === 'ArrowLeft' || e.key === 'a') this.player.move(-1);
                    if (e.key === 'ArrowRight' || e.key === 'd') this.player.move(1);
                });

                // Mobile Touch
                let touchStartX = 0;
                document.addEventListener('touchstart', e => touchStartX = e.touches[0].clientX);
                document.addEventListener('touchend', e => {
                    if (this.state !== 'PLAYING') return;
                    const deltaX = e.changedTouches[0].clientX - touchStartX;
                    if (Math.abs(deltaX) > 30) {
                        this.player.move(deltaX > 0 ? 1 : -1);
                    }
                });
            }

            startGame() {
                this.state = 'PLAYING';
                this.score = 0;
                this.speed = CONFIG.baseSpeed;
                this.player.reset();
                this.obstacles.reset();
                this.gameOverScreen.classList.remove('active');
                this.clock.start();
            }

            gameOver() {
                this.state = 'GAMEOVER';
                this.gameOverScreen.classList.add('active');
                
                // Shake effect
                const shakeIntensity = 0.5;
                this.camera.position.x += (Math.random() - 0.5) * shakeIntensity;
                this.camera.position.y += (Math.random() - 0.5) * shakeIntensity;
            }

            restart() {
                this.startGame();
            }

            animate() {
                requestAnimationFrame(this.animate);

                const dt = this.clock.getDelta();
                const time = this.clock.getElapsedTime();

                if (this.state === 'PLAYING') {
                    // Game Logic
                    this.speed = Math.min(this.speed + CONFIG.acceleration, CONFIG.maxSpeed);
                    this.score += Math.floor(this.speed * 10);
                    this.scoreEl.innerText = this.score.toLocaleString();

                    this.player.update(dt, time);
                    this.obstacles.update(dt, this.speed, this.player.mesh);
                    this.env.update(this.speed, dt);
                    
                    // Camera Follow with lag
                    this.camera.position.x = MathUtils.lerp(this.camera.position.x, this.player.mesh.position.x * 0.3, dt * 2);
                }

                // Render via Composer for Bloom
                this.composer.render();
            }
        }

        // Initialize Global Namespace
        window.GameCore = new Engine();

    </script>
</body>
</html>
```
